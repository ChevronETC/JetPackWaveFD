<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · JetPackWaveFD.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JetPackWaveFD.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">JetPackWaveFD</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopLnProp2DAcoIsoDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopLnProp2DAcoIsoDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp2DAcoIsoDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; kwargs...)
JopLnProp2DAcoIsoDenQ_DEO2_FDTD(; v, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 2D visco-acoustic, isotropic,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with two model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr></table><p>Velocity <code>v</code> is an <strong>active</strong> parameter and can be inverted for using the Jacobian machinery,  and buoyancy <code>b</code> is a <strong>passive</strong> parameter that is constant.</p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant buoyancy array</li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,nx = 200, 100                      # spatial discretization size
dz,dx = 20.0, 20.0                    # spatial discretization sampling
ntrec = 1101                          # number of temporal samples in recorded data
dtrec = 0.0100                        # sample rate for recorded data
dtmod = 0.0025                        # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) 
sz = dz                               # source Z location 
sx = dx*(nx/2)                        # source X location 
rx = dx*[0:0.5:nx-1;];                # array of receiver X locations
rz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations
b = ones(Float32, nz, nx);            # buoyancy model (reciprocal density)</code></pre><p><strong>Construct and apply the nonlinear operator</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the constant velocity model m₀ </li><li>perform nonlinear forward modeling with constant velocity model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, 
    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = 1500 .* ones(domain(F));
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, 
    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = 1500 .* ones(domain(F));
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><ol><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = 1500 * ones(Float32, nz, nx);
J = JopLnProp2DAcoIsoDenQ_DEO2_FDTD(; v = m₀, b = b, ntrec = ntrec, 
    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sx = sx, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>v</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoIsoDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoIsoDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-3cd0f544-8f33-475c-8980-3a618fe7d06b.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, nx_subcube [32]</code> The Z and X sizes of windows used for compression    of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.<ul><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is</li></ul>saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, padx [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nbx_cache [512], [8]</code> The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nbx_inject = [16], [16]</code> The number of blocks in the Z and X dimensions for threading    the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop2DAcoIsoDenQ_DEO2_FDTD.jl#L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopLnProp2DAcoTTIDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopLnProp2DAcoTTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp2DAcoTTIDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; kwargs...)
JopLnProp2DAcoTTIDenQ_DEO2_FDTD(; m₀, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 2D pseudo- visco-acoustic, tilted transverse isotropy,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with five model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>ϵ</code></td><td style="text-align: left">Modified Thomsen&#39;s weak anisotropy parameter</td></tr><tr><td style="text-align: center"><code>η</code></td><td style="text-align: left">Modified Alkhalifah&#39;s weak anisotropy parameter η</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr><tr><td style="text-align: center"><code>θ</code></td><td style="text-align: left">symmetry axis tilt angle from vertical (radians)</td></tr></table><p><strong>Pseudo-acoustic approximation</strong></p><p>With the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter <code>f</code> representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah&#39;s weak anisotropy parameter <code>η</code>. We show formulas for these two parameters below.  The parameter <code>f</code> is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.</p><ul><li><code>η = sqrt[2(ϵ-δ)/(f+2ϵ)]</code></li><li><code>f = 1 - Vₛ² / Vₚ²</code></li></ul><p>For more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. </p><p><strong>Active and passive model parameters</strong></p><p>There are two modes of operation that define different sets of <strong>active</strong> and <strong>passive</strong> parameters,  <em>velocity only</em> and <em>velocity and anisotropy</em>. </p><p>An <strong>active</strong> parameter can be inverted for using the Jacobian linearized operator machinery,   and a <strong>passive</strong> parameter is constant. The two modes are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Active Parameters</th><th style="text-align: left">Passive Parameters</th></tr><tr><td style="text-align: left">velocity only</td><td style="text-align: left">[<code>v</code>]</td><td style="text-align: left">[<code>ϵ</code>, <code>η</code>, <code>b</code>, <code>θ</code> ]</td></tr><tr><td style="text-align: left">velocity and anisotropy</td><td style="text-align: left">[<code>v</code>, <code>ϵ</code>, <code>η</code>]</td><td style="text-align: left">[<code>b</code>, <code>θ</code> ]</td></tr></table><p>To make a parameter <strong>passive</strong>, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are <em>not</em> passed to the constructor are assumed to be <strong>active</strong>, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  <code>[Z coord][X coord][Active Parameter]</code></p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant models for <code>v</code>, <code>ϵ</code>, <code>η</code>, <code>b</code>, <code>θ</code></li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,nx = 200, 100                      # spatial discretization size
dz,dx = 20.0, 20.0                    # spatial discretization sampling
ntrec = 1101                          # number of temporal samples in recorded data
dtrec = 0.0100                        # sample rate for recorded data
dtmod = 0.0025                        # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) 
sz = dz                               # source Z location 
sx = dx*(nx/2)                        # source X location 
rx = dx*[0:0.5:nx-1;];                # array of receiver X locations
rz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations
b = ones(Float32, nz, nx);            # constant buoyancy
ϵ = 0.1 * ones(Float32, nz, nx);      # constant epsilon
η = 0.2 * ones(Float32, nz, nx);      # constant eta
θ = (π/8) * ones(Float32, nz, nx);    # constant tilt angle</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v</code> is active; <code>ϵ, η, b, θ</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameter <code>v</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, θ = θ, ntrec = ntrec, dtrec = dtrec, 
    dtmod = dtmod, dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v, ϵ, η</code> are active; <code>b, θ</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ntrec = ntrec, dtrec = dtrec, dtmod = dtmod, 
    dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b, θ</code> are passive.</p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ntrec = ntrec, dz = dz, dx = dx, 
    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b, θ</code> are passive.</p><ol><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = zeros(Float32, nz, nx, 3);
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
J = JopLnProp2DAcoTTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, θ = θ, ntrec = ntrec, dz = dz, dx = dx, 
    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>m₀</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoTTIDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoTTIDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>θ [zeros(Float32,0,0)]</code> the symmetry axies tilt angle in radians. Assumed to be zero if not    specified. θ must be an array the same size as buoyancy <code>b</code>. </li><li><code>f [0.85]</code> See the discussion above regarding the <strong>Pseudo-acoustic approximation</strong> used here</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-fe97573d-9901-4d1f-a7fd-4b681d8442e9.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, nx_subcube [32]</code> The Z and X sizes of windows used for compression    of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.<ul><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is</li></ul>saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, padx [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nbx_cache [512], [8]</code> The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nbx_inject = [16], [16]</code> The number of blocks in the Z and X dimensions for threading    the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop2DAcoTTIDenQ_DEO2_FDTD.jl#L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopLnProp2DAcoVTIDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopLnProp2DAcoVTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp2DAcoVTIDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; kwargs...)
JopLnProp2DAcoVTIDenQ_DEO2_FDTD(; m₀, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 2D pseudo- visco-acoustic, vertical transverse isotropy,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with four model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>ϵ</code></td><td style="text-align: left">Modified Thomsen&#39;s weak anisotropy parameter</td></tr><tr><td style="text-align: center"><code>η</code></td><td style="text-align: left">Modified Alkhalifah&#39;s weak anisotropy parameter η</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr></table><p><strong>Pseudo-acoustic approximation</strong></p><p>With the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter <code>f</code> representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah&#39;s weak anisotropy parameter <code>η</code>. We show formulas for these two parameters below.  The parameter <code>f</code> is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.</p><ul><li><code>η = sqrt[2(ϵ-δ)/(f+2ϵ)]</code></li><li><code>f = 1 - Vₛ² / Vₚ²</code></li></ul><p>For more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. </p><p><strong>Active and passive model parameters</strong></p><p>There are two modes of operation that define different sets of <strong>active</strong> and <strong>passive</strong> parameters,  <em>velocity only</em> and <em>velocity and anisotropy</em>. </p><p>An <strong>active</strong> parameter can be inverted for using the Jacobian linearized operator machinery,   and a <strong>passive</strong> parameter is constant. The two modes are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Active Parameters</th><th style="text-align: left">Passive Parameters</th></tr><tr><td style="text-align: left">velocity only</td><td style="text-align: left">[<code>v</code>]</td><td style="text-align: left">[<code>ϵ</code>, <code>η</code>, <code>b</code>]</td></tr><tr><td style="text-align: left">velocity and anisotropy</td><td style="text-align: left">[<code>v</code>, <code>ϵ</code>, <code>η</code>]</td><td style="text-align: left">[<code>b</code>]</td></tr></table><p>To make a parameter <strong>passive</strong>, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are <em>not</em> passed to the constructor are assumed to be <strong>active</strong>, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  <code>[Z coord][X coord][Active Parameter]</code></p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant models for <code>v</code>, <code>ϵ</code>, <code>η</code>, <code>b</code></li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,nx = 200, 100                      # spatial discretization size
dz,dx = 20.0, 20.0                    # spatial discretization sampling
ntrec = 1101                          # number of temporal samples in recorded data
dtrec = 0.0100                        # sample rate for recorded data
dtmod = 0.0025                        # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) 
sz = dz                               # source Z location 
sx = dx*(nx/2)                        # source X location 
rx = dx*[0:0.5:nx-1;];                # array of receiver X locations
rz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations
b = ones(Float32, nz, nx);            # constant buoyancy
ϵ = 0.1 * ones(Float32, nz, nx);      # constant epsilon
η = 0.2 * ones(Float32, nz, nx);      # constant eta</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v</code> is active; <code>ϵ, η, b</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameter <code>v</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, ntrec = ntrec, dtrec = dtrec, 
    dtmod = dtmod, dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v, ϵ, η</code> are active; <code>b</code> is passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, dtrec = dtrec, dtmod = dtmod,
    dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b</code> is passive.</p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, dz = dz, dx = dx, 
    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b</code> is passive.</p><ol><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = zeros(Float32, nz, nx, 3);
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
J = JopLnProp2DAcoVTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, ntrec = ntrec, dz = dz, dx = dx, 
    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>m₀</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoVTIDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoVTIDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>f [0.85]</code> See the discussion above regarding the <strong>Pseudo-acoustic approximation</strong> used here</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-3c6d9f35-91e9-4c16-a740-0aea015fb5fd.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, nx_subcube [32]</code> The Z and X sizes of windows used for compression    of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.<ul><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is</li></ul>saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, padx [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nbx_cache [512], [8]</code> The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nbx_inject = [16], [16]</code> The number of blocks in the Z and X dimensions for threading    the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop2DAcoVTIDenQ_DEO2_FDTD.jl#L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopLnProp3DAcoIsoDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopLnProp3DAcoIsoDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp3DAcoIsoDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; kwargs...)
JopLnProp3DAcoIsoDenQ_DEO2_FDTD(; v, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 3D visco-acoustic, isotropic,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with two model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr></table><p>Velocity <code>v</code> is an <strong>active</strong> parameter and can be inverted for using the Jacobian machinery,  and buoyancy <code>b</code> is a <strong>passive</strong> parameter that is constant.</p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant buoyancy array</li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,ny,nx = 100, 80, 60                        # spatial discretization size
dz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling
ntrec = 1101                                  # number of temporal samples in recorded data
dtrec = 0.0100                                # sample rate for recorded data
dtmod = 0.0025                                # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) 
sz = dz                                       # source Z location 
sy = dy*(ny/2)                                # source Y location 
sx = dx*(nx/2)                                # source X location 
rz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations 
ry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations
rx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations
b = ones(Float32, nz, ny, nx);                # buoyancy model (reciprocal density)</code></pre><p><strong>Construct and apply the nonlinear operator</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the constant velocity model m₀ </li><li>perform nonlinear forward modeling with constant velocity model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, 
    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = 1500 .* ones(domain(F));
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, 
    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = 1500 .* ones(domain(F));
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><ol><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = 1500 .* ones(Float32, nz, ny, nx);       # velocity model
J = JopLnProp3DAcoIsoDenQ_DEO2_FDTD(; v = m₀, b = b, isinterior=true, nsponge = 10, ntrec = ntrec, 
    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>v</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp3DAcoIsoDenQ_DEO2_FDTD</code> but not <code>JopNlProp3DAcoIsoDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-9db7fef9-da73-49af-8bb2-f93084b4db1f.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, ny_subcubem, nx_subcube [32]</code> The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.</li><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sy [0.0]</code> Array of source Y coordinate.</li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>ry [[0.0]]</code> 2D array of receiver Y coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>y0 [0.0]</code> Origin of physical coordinates for the Y dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dy [10.0]</code> Spacing of physical coordinates in the Y dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, pady, padx [0.0], [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nby_cache, nbx_cache [512], [8], [8]</code> The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nby_inject, nbx_inject = [16], [16], [16]</code> The number of blocks in the Z, Y, and X    dimensions for threading the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop3DAcoIsoDenQ_DEO2_FDTD.jl#L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopLnProp3DAcoTTIDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopLnProp3DAcoTTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp3DAcoTTIDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; kwargs...)
JopLnProp3DAcoTTIDenQ_DEO2_FDTD(; m₀, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 3D pseudo- visco-acoustic, tilted transverse isotropy,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with four model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>ϵ</code></td><td style="text-align: left">Modified Thomsen&#39;s weak anisotropy parameter</td></tr><tr><td style="text-align: center"><code>η</code></td><td style="text-align: left">Modified Alkhalifah&#39;s weak anisotropy parameter η</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr><tr><td style="text-align: center"><code>θ</code></td><td style="text-align: left">symmetry axis tilt angle from vertical (radians)</td></tr><tr><td style="text-align: center"><code>ϕ</code></td><td style="text-align: left">symmetry axis aziumuth angle CCW from x (radians)</td></tr></table><p><strong>Pseudo-acoustic approximation</strong></p><p>With the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter <code>f</code> representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah&#39;s weak anisotropy parameter <code>η</code>. We show formulas for these two parameters below.  The parameter <code>f</code> is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.</p><ul><li><code>η = sqrt[2(ϵ-δ)/(f+2ϵ)]</code></li><li><code>f = 1 - Vₛ² / Vₚ²</code></li></ul><p>For more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. </p><p><strong>Active and passive model parameters</strong></p><p>There are two modes of operation that define different sets of <strong>active</strong> and <strong>passive</strong> parameters,  <em>velocity only</em> and <em>velocity and anisotropy</em>. </p><p>An <strong>active</strong> parameter can be inverted for using the Jacobian linearized operator machinery,   and a <strong>passive</strong> parameter is constant. The two modes are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Active Parameters</th><th style="text-align: left">Passive Parameters</th></tr><tr><td style="text-align: left">velocity only</td><td style="text-align: left">[<code>v</code>]</td><td style="text-align: left">[<code>ϵ</code>, <code>η</code>, <code>b</code>, <code>θ</code>, <code>ϕ</code> ]</td></tr><tr><td style="text-align: left">velocity and anisotropy</td><td style="text-align: left">[<code>v</code>, <code>ϵ</code>, <code>η</code>]</td><td style="text-align: left">[<code>b</code>, <code>θ</code>, <code>ϕ</code> ]</td></tr></table><p>To make a parameter <strong>passive</strong>, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are <em>not</em> passed to the constructor are assumed to be <strong>active</strong>, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  <code>[Z coord][X coord][Active Parameter]</code></p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFDFDFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant models for <code>v</code>, <code>ϵ</code>, <code>η</code>, <code>b</code>, <code>θ</code>, <code>ϕ</code></li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFDFDFD
nz,ny,nx = 100, 80, 60                        # spatial discretization size
dz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling
ntrec = 1101                                  # number of temporal samples in recorded data
dtrec = 0.0100                                # sample rate for recorded data
dtmod = 0.0025                                # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) 
sz = dz                                       # source Z location 
sy = dy*(ny/2)                                # source Y location 
sx = dx*(nx/2)                                # source X location 
rz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations 
ry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations
rx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations
b = ones(Float32, nz, ny, nx);                # constant buoyancy
ϵ = 0.1 * ones(Float32, nz, ny, nx);          # constant epsilon
η = 0.2 * ones(Float32, nz, ny, nx);          # constant eta
θ = (π/8) * ones(Float32, nz, ny, nx);        # constant tilt angle
ϕ = (π/3) * ones(Float32, nz, ny, nx);        # constant azimuth angle</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v</code> is active; <code>ϵ, η, b, θ, ϕ</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the constant velocity model m₀ </li><li>perform nonlinear forward modeling with constant velocity model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v, ϵ, η</code> are active; <code>b, θ, ϕ</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b, θ, ϕ</code> are passive.</p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b, θ, ϕ</code> are passive.</p><ol><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = zeros(Float32, nz, ny, nx, 3);
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
J = JopLnProp3DAcoTTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>m₀</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoTTIDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoTTIDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>ϕ [zeros(Float32,0,0,0)]</code> the symmetry axies azimuth angle counter-clockwise from the x axis, in radians.    Assumed to be zero if not specified. </li><li><code>θ [zeros(Float32,0,0,0)]</code> the symmetry axies tilt angle in radians. Assumed to be zero if not    specified. θ must be an array the same size as buoyancy <code>b</code>. </li><li><code>f [0.85]</code> See the discussion above regarding the <strong>Pseudo-acoustic approximation</strong> used here</li><li><code>srcfieldfile [&quot;field-20458c83-0b07-4064-863c-25e28b935c88.bin&quot;]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, ny_subcubem, nx_subcube [32]</code> The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.</li><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sy [0.0]</code> Array of source Y coordinate.</li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>ry [[0.0]]</code> 2D array of receiver Y coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>y0 [0.0]</code> Origin of physical coordinates for the Y dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dy [10.0]</code> Spacing of physical coordinates in the Y dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFDFDFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFDFDFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFDFDFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, pady, padx [0.0], [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nby_cache, nbx_cache [512], [8], [8]</code> The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nby_inject, nbx_inject = [16], [16], [16]</code> The number of blocks in the Z, Y, and X    dimensions for threading the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop3DAcoTTIDenQ_DEO2_FDTD.jl#L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopLnProp3DAcoVTIDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopLnProp3DAcoVTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp3DAcoVTIDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; kwargs...)
JopLnProp3DAcoVTIDenQ_DEO2_FDTD(; m₀, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 3D pseudo- visco-acoustic, vertical transverse isotropy,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with four model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>ϵ</code></td><td style="text-align: left">Modified Thomsen&#39;s weak anisotropy parameter</td></tr><tr><td style="text-align: center"><code>η</code></td><td style="text-align: left">Modified Alkhalifah&#39;s weak anisotropy parameter η</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr></table><p><strong>Pseudo-acoustic approximation</strong></p><p>With the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter <code>f</code> representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah&#39;s weak anisotropy parameter <code>η</code>. We show formulas for these two parameters below.  The parameter <code>f</code> is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.</p><ul><li><code>η = sqrt[2(ϵ-δ)/(f+2ϵ)]</code></li><li><code>f = 1 - Vₛ² / Vₚ²</code></li></ul><p>For more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. </p><p><strong>Active and passive model parameters</strong></p><p>There are two modes of operation that define different sets of <strong>active</strong> and <strong>passive</strong> parameters,  <em>velocity only</em> and <em>velocity and anisotropy</em>. </p><p>An <strong>active</strong> parameter can be inverted for using the Jacobian linearized operator machinery,   and a <strong>passive</strong> parameter is constant. The two modes are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Active Parameters</th><th style="text-align: left">Passive Parameters</th></tr><tr><td style="text-align: left">velocity only</td><td style="text-align: left">[<code>v</code>]</td><td style="text-align: left">[<code>ϵ</code>, <code>η</code>, <code>b</code>]</td></tr><tr><td style="text-align: left">velocity and anisotropy</td><td style="text-align: left">[<code>v</code>, <code>ϵ</code>, <code>η</code>]</td><td style="text-align: left">[<code>b</code>]</td></tr></table><p>To make a parameter <strong>passive</strong>, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are <em>not</em> passed to the constructor are assumed to be <strong>active</strong>, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  <code>[Z coord][X coord][Active Parameter]</code></p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant models for <code>v</code>, <code>ϵ</code>, <code>η</code>, <code>b</code></li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,ny,nx = 100, 80, 60                        # spatial discretization size
dz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling
ntrec = 1101                                  # number of temporal samples in recorded data
dtrec = 0.0100                                # sample rate for recorded data
dtmod = 0.0025                                # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) 
sz = dz                                       # source Z location 
sy = dy*(ny/2)                                # source Y location 
sx = dx*(nx/2)                                # source X location 
rz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations 
ry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations
rx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations
b = ones(Float32, nz, ny, nx);                # constant buoyancy
ϵ = 0.1 * ones(Float32, nz, ny, nx);          # constant epsilon
η = 0.2 * ones(Float32, nz, ny, nx);          # constant eta</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v</code> is active; <code>ϵ, η, b</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the constant velocity model m₀ </li><li>perform nonlinear forward modeling with constant velocity model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v, ϵ, η</code> are active; <code>b</code> is passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b</code> is passive.</p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, 
    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b</code> is passive.</p><ol><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = zeros(Float32, nz, ny, nx, 3);
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
J = JopLnProp3DAcoVTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>m₀</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoVTIDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoVTIDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>f [0.85]</code> See the discussion above regarding the <strong>Pseudo-acoustic approximation</strong> used here</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-1664bcbe-3b6f-41dc-935d-f56d29505bde.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, ny_subcubem, nx_subcube [32]</code> The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.</li><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sy [0.0]</code> Array of source Y coordinate.</li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>ry [[0.0]]</code> 2D array of receiver Y coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>y0 [0.0]</code> Origin of physical coordinates for the Y dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dy [10.0]</code> Spacing of physical coordinates in the Y dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, pady, padx [0.0], [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nby_cache, nbx_cache [512], [8], [8]</code> The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nby_inject, nbx_inject = [16], [16], [16]</code> The number of blocks in the Z, Y, and X    dimensions for threading the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop3DAcoVTIDenQ_DEO2_FDTD.jl#L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopNlProp2DAcoIsoDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopNlProp2DAcoIsoDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp2DAcoIsoDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; kwargs...)
JopLnProp2DAcoIsoDenQ_DEO2_FDTD(; v, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 2D visco-acoustic, isotropic,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with two model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr></table><p>Velocity <code>v</code> is an <strong>active</strong> parameter and can be inverted for using the Jacobian machinery,  and buoyancy <code>b</code> is a <strong>passive</strong> parameter that is constant.</p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant buoyancy array</li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,nx = 200, 100                      # spatial discretization size
dz,dx = 20.0, 20.0                    # spatial discretization sampling
ntrec = 1101                          # number of temporal samples in recorded data
dtrec = 0.0100                        # sample rate for recorded data
dtmod = 0.0025                        # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) 
sz = dz                               # source Z location 
sx = dx*(nx/2)                        # source X location 
rx = dx*[0:0.5:nx-1;];                # array of receiver X locations
rz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations
b = ones(Float32, nz, nx);            # buoyancy model (reciprocal density)</code></pre><p><strong>Construct and apply the nonlinear operator</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the constant velocity model m₀ </li><li>perform nonlinear forward modeling with constant velocity model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, 
    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = 1500 .* ones(domain(F));
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, 
    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = 1500 .* ones(domain(F));
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><ol><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = 1500 * ones(Float32, nz, nx);
J = JopLnProp2DAcoIsoDenQ_DEO2_FDTD(; v = m₀, b = b, ntrec = ntrec, 
    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sx = sx, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>v</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoIsoDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoIsoDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-3cd0f544-8f33-475c-8980-3a618fe7d06b.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, nx_subcube [32]</code> The Z and X sizes of windows used for compression    of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.<ul><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is</li></ul>saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, padx [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nbx_cache [512], [8]</code> The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nbx_inject = [16], [16]</code> The number of blocks in the Z and X dimensions for threading    the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop2DAcoIsoDenQ_DEO2_FDTD.jl#L119-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopNlProp2DAcoTTIDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopNlProp2DAcoTTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp2DAcoTTIDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; kwargs...)
JopLnProp2DAcoTTIDenQ_DEO2_FDTD(; m₀, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 2D pseudo- visco-acoustic, tilted transverse isotropy,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with five model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>ϵ</code></td><td style="text-align: left">Modified Thomsen&#39;s weak anisotropy parameter</td></tr><tr><td style="text-align: center"><code>η</code></td><td style="text-align: left">Modified Alkhalifah&#39;s weak anisotropy parameter η</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr><tr><td style="text-align: center"><code>θ</code></td><td style="text-align: left">symmetry axis tilt angle from vertical (radians)</td></tr></table><p><strong>Pseudo-acoustic approximation</strong></p><p>With the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter <code>f</code> representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah&#39;s weak anisotropy parameter <code>η</code>. We show formulas for these two parameters below.  The parameter <code>f</code> is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.</p><ul><li><code>η = sqrt[2(ϵ-δ)/(f+2ϵ)]</code></li><li><code>f = 1 - Vₛ² / Vₚ²</code></li></ul><p>For more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. </p><p><strong>Active and passive model parameters</strong></p><p>There are two modes of operation that define different sets of <strong>active</strong> and <strong>passive</strong> parameters,  <em>velocity only</em> and <em>velocity and anisotropy</em>. </p><p>An <strong>active</strong> parameter can be inverted for using the Jacobian linearized operator machinery,   and a <strong>passive</strong> parameter is constant. The two modes are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Active Parameters</th><th style="text-align: left">Passive Parameters</th></tr><tr><td style="text-align: left">velocity only</td><td style="text-align: left">[<code>v</code>]</td><td style="text-align: left">[<code>ϵ</code>, <code>η</code>, <code>b</code>, <code>θ</code> ]</td></tr><tr><td style="text-align: left">velocity and anisotropy</td><td style="text-align: left">[<code>v</code>, <code>ϵ</code>, <code>η</code>]</td><td style="text-align: left">[<code>b</code>, <code>θ</code> ]</td></tr></table><p>To make a parameter <strong>passive</strong>, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are <em>not</em> passed to the constructor are assumed to be <strong>active</strong>, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  <code>[Z coord][X coord][Active Parameter]</code></p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant models for <code>v</code>, <code>ϵ</code>, <code>η</code>, <code>b</code>, <code>θ</code></li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,nx = 200, 100                      # spatial discretization size
dz,dx = 20.0, 20.0                    # spatial discretization sampling
ntrec = 1101                          # number of temporal samples in recorded data
dtrec = 0.0100                        # sample rate for recorded data
dtmod = 0.0025                        # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) 
sz = dz                               # source Z location 
sx = dx*(nx/2)                        # source X location 
rx = dx*[0:0.5:nx-1;];                # array of receiver X locations
rz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations
b = ones(Float32, nz, nx);            # constant buoyancy
ϵ = 0.1 * ones(Float32, nz, nx);      # constant epsilon
η = 0.2 * ones(Float32, nz, nx);      # constant eta
θ = (π/8) * ones(Float32, nz, nx);    # constant tilt angle</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v</code> is active; <code>ϵ, η, b, θ</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameter <code>v</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, θ = θ, ntrec = ntrec, dtrec = dtrec, 
    dtmod = dtmod, dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v, ϵ, η</code> are active; <code>b, θ</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ntrec = ntrec, dtrec = dtrec, dtmod = dtmod, 
    dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b, θ</code> are passive.</p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ntrec = ntrec, dz = dz, dx = dx, 
    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b, θ</code> are passive.</p><ol><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = zeros(Float32, nz, nx, 3);
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
J = JopLnProp2DAcoTTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, θ = θ, ntrec = ntrec, dz = dz, dx = dx, 
    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>m₀</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoTTIDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoTTIDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>θ [zeros(Float32,0,0)]</code> the symmetry axies tilt angle in radians. Assumed to be zero if not    specified. θ must be an array the same size as buoyancy <code>b</code>. </li><li><code>f [0.85]</code> See the discussion above regarding the <strong>Pseudo-acoustic approximation</strong> used here</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-fe97573d-9901-4d1f-a7fd-4b681d8442e9.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, nx_subcube [32]</code> The Z and X sizes of windows used for compression    of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.<ul><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is</li></ul>saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, padx [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nbx_cache [512], [8]</code> The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nbx_inject = [16], [16]</code> The number of blocks in the Z and X dimensions for threading    the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop2DAcoTTIDenQ_DEO2_FDTD.jl#L163-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopNlProp2DAcoVTIDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopNlProp2DAcoVTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp2DAcoVTIDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; kwargs...)
JopLnProp2DAcoVTIDenQ_DEO2_FDTD(; m₀, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 2D pseudo- visco-acoustic, vertical transverse isotropy,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with four model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>ϵ</code></td><td style="text-align: left">Modified Thomsen&#39;s weak anisotropy parameter</td></tr><tr><td style="text-align: center"><code>η</code></td><td style="text-align: left">Modified Alkhalifah&#39;s weak anisotropy parameter η</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr></table><p><strong>Pseudo-acoustic approximation</strong></p><p>With the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter <code>f</code> representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah&#39;s weak anisotropy parameter <code>η</code>. We show formulas for these two parameters below.  The parameter <code>f</code> is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.</p><ul><li><code>η = sqrt[2(ϵ-δ)/(f+2ϵ)]</code></li><li><code>f = 1 - Vₛ² / Vₚ²</code></li></ul><p>For more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. </p><p><strong>Active and passive model parameters</strong></p><p>There are two modes of operation that define different sets of <strong>active</strong> and <strong>passive</strong> parameters,  <em>velocity only</em> and <em>velocity and anisotropy</em>. </p><p>An <strong>active</strong> parameter can be inverted for using the Jacobian linearized operator machinery,   and a <strong>passive</strong> parameter is constant. The two modes are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Active Parameters</th><th style="text-align: left">Passive Parameters</th></tr><tr><td style="text-align: left">velocity only</td><td style="text-align: left">[<code>v</code>]</td><td style="text-align: left">[<code>ϵ</code>, <code>η</code>, <code>b</code>]</td></tr><tr><td style="text-align: left">velocity and anisotropy</td><td style="text-align: left">[<code>v</code>, <code>ϵ</code>, <code>η</code>]</td><td style="text-align: left">[<code>b</code>]</td></tr></table><p>To make a parameter <strong>passive</strong>, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are <em>not</em> passed to the constructor are assumed to be <strong>active</strong>, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  <code>[Z coord][X coord][Active Parameter]</code></p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant models for <code>v</code>, <code>ϵ</code>, <code>η</code>, <code>b</code></li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,nx = 200, 100                      # spatial discretization size
dz,dx = 20.0, 20.0                    # spatial discretization sampling
ntrec = 1101                          # number of temporal samples in recorded data
dtrec = 0.0100                        # sample rate for recorded data
dtmod = 0.0025                        # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) 
sz = dz                               # source Z location 
sx = dx*(nx/2)                        # source X location 
rx = dx*[0:0.5:nx-1;];                # array of receiver X locations
rz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations
b = ones(Float32, nz, nx);            # constant buoyancy
ϵ = 0.1 * ones(Float32, nz, nx);      # constant epsilon
η = 0.2 * ones(Float32, nz, nx);      # constant eta</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v</code> is active; <code>ϵ, η, b</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameter <code>v</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, ntrec = ntrec, dtrec = dtrec, 
    dtmod = dtmod, dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v, ϵ, η</code> are active; <code>b</code> is passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, dtrec = dtrec, dtmod = dtmod,
    dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b</code> is passive.</p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, dz = dz, dx = dx, 
    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b</code> is passive.</p><ol><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = zeros(Float32, nz, nx, 3);
m₀[:,:,1] .= 1500;
m₀[:,:,2] .= 0.1;
m₀[:,:,3] .= 0.2;
J = JopLnProp2DAcoVTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, ntrec = ntrec, dz = dz, dx = dx, 
    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>m₀</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoVTIDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoVTIDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>f [0.85]</code> See the discussion above regarding the <strong>Pseudo-acoustic approximation</strong> used here</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-3c6d9f35-91e9-4c16-a740-0aea015fb5fd.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, nx_subcube [32]</code> The Z and X sizes of windows used for compression    of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.<ul><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is</li></ul>saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, padx [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nbx_cache [512], [8]</code> The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nbx_inject = [16], [16]</code> The number of blocks in the Z and X dimensions for threading    the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop2DAcoVTIDenQ_DEO2_FDTD.jl#L159-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopNlProp3DAcoIsoDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopNlProp3DAcoIsoDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp3DAcoIsoDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; kwargs...)
JopLnProp3DAcoIsoDenQ_DEO2_FDTD(; v, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 3D visco-acoustic, isotropic,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with two model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr></table><p>Velocity <code>v</code> is an <strong>active</strong> parameter and can be inverted for using the Jacobian machinery,  and buoyancy <code>b</code> is a <strong>passive</strong> parameter that is constant.</p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant buoyancy array</li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,ny,nx = 100, 80, 60                        # spatial discretization size
dz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling
ntrec = 1101                                  # number of temporal samples in recorded data
dtrec = 0.0100                                # sample rate for recorded data
dtmod = 0.0025                                # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) 
sz = dz                                       # source Z location 
sy = dy*(ny/2)                                # source Y location 
sx = dx*(nx/2)                                # source X location 
rz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations 
ry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations
rx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations
b = ones(Float32, nz, ny, nx);                # buoyancy model (reciprocal density)</code></pre><p><strong>Construct and apply the nonlinear operator</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the constant velocity model m₀ </li><li>perform nonlinear forward modeling with constant velocity model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, 
    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = 1500 .* ones(domain(F));
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, 
    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = 1500 .* ones(domain(F));
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><ol><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = 1500 .* ones(Float32, nz, ny, nx);       # velocity model
J = JopLnProp3DAcoIsoDenQ_DEO2_FDTD(; v = m₀, b = b, isinterior=true, nsponge = 10, ntrec = ntrec, 
    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>v</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp3DAcoIsoDenQ_DEO2_FDTD</code> but not <code>JopNlProp3DAcoIsoDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-9db7fef9-da73-49af-8bb2-f93084b4db1f.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, ny_subcubem, nx_subcube [32]</code> The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.</li><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sy [0.0]</code> Array of source Y coordinate.</li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>ry [[0.0]]</code> 2D array of receiver Y coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>y0 [0.0]</code> Origin of physical coordinates for the Y dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dy [10.0]</code> Spacing of physical coordinates in the Y dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, pady, padx [0.0], [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nby_cache, nbx_cache [512], [8], [8]</code> The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nby_inject, nbx_inject = [16], [16], [16]</code> The number of blocks in the Z, Y, and X    dimensions for threading the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop3DAcoIsoDenQ_DEO2_FDTD.jl#L138-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopNlProp3DAcoTTIDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopNlProp3DAcoTTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp3DAcoTTIDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; kwargs...)
JopLnProp3DAcoTTIDenQ_DEO2_FDTD(; m₀, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 3D pseudo- visco-acoustic, tilted transverse isotropy,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with four model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>ϵ</code></td><td style="text-align: left">Modified Thomsen&#39;s weak anisotropy parameter</td></tr><tr><td style="text-align: center"><code>η</code></td><td style="text-align: left">Modified Alkhalifah&#39;s weak anisotropy parameter η</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr><tr><td style="text-align: center"><code>θ</code></td><td style="text-align: left">symmetry axis tilt angle from vertical (radians)</td></tr><tr><td style="text-align: center"><code>ϕ</code></td><td style="text-align: left">symmetry axis aziumuth angle CCW from x (radians)</td></tr></table><p><strong>Pseudo-acoustic approximation</strong></p><p>With the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter <code>f</code> representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah&#39;s weak anisotropy parameter <code>η</code>. We show formulas for these two parameters below.  The parameter <code>f</code> is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.</p><ul><li><code>η = sqrt[2(ϵ-δ)/(f+2ϵ)]</code></li><li><code>f = 1 - Vₛ² / Vₚ²</code></li></ul><p>For more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. </p><p><strong>Active and passive model parameters</strong></p><p>There are two modes of operation that define different sets of <strong>active</strong> and <strong>passive</strong> parameters,  <em>velocity only</em> and <em>velocity and anisotropy</em>. </p><p>An <strong>active</strong> parameter can be inverted for using the Jacobian linearized operator machinery,   and a <strong>passive</strong> parameter is constant. The two modes are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Active Parameters</th><th style="text-align: left">Passive Parameters</th></tr><tr><td style="text-align: left">velocity only</td><td style="text-align: left">[<code>v</code>]</td><td style="text-align: left">[<code>ϵ</code>, <code>η</code>, <code>b</code>, <code>θ</code>, <code>ϕ</code> ]</td></tr><tr><td style="text-align: left">velocity and anisotropy</td><td style="text-align: left">[<code>v</code>, <code>ϵ</code>, <code>η</code>]</td><td style="text-align: left">[<code>b</code>, <code>θ</code>, <code>ϕ</code> ]</td></tr></table><p>To make a parameter <strong>passive</strong>, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are <em>not</em> passed to the constructor are assumed to be <strong>active</strong>, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  <code>[Z coord][X coord][Active Parameter]</code></p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFDFDFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant models for <code>v</code>, <code>ϵ</code>, <code>η</code>, <code>b</code>, <code>θ</code>, <code>ϕ</code></li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFDFDFD
nz,ny,nx = 100, 80, 60                        # spatial discretization size
dz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling
ntrec = 1101                                  # number of temporal samples in recorded data
dtrec = 0.0100                                # sample rate for recorded data
dtmod = 0.0025                                # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) 
sz = dz                                       # source Z location 
sy = dy*(ny/2)                                # source Y location 
sx = dx*(nx/2)                                # source X location 
rz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations 
ry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations
rx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations
b = ones(Float32, nz, ny, nx);                # constant buoyancy
ϵ = 0.1 * ones(Float32, nz, ny, nx);          # constant epsilon
η = 0.2 * ones(Float32, nz, ny, nx);          # constant eta
θ = (π/8) * ones(Float32, nz, ny, nx);        # constant tilt angle
ϕ = (π/3) * ones(Float32, nz, ny, nx);        # constant azimuth angle</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v</code> is active; <code>ϵ, η, b, θ, ϕ</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the constant velocity model m₀ </li><li>perform nonlinear forward modeling with constant velocity model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v, ϵ, η</code> are active; <code>b, θ, ϕ</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b, θ, ϕ</code> are passive.</p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b, θ, ϕ</code> are passive.</p><ol><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = zeros(Float32, nz, ny, nx, 3);
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
J = JopLnProp3DAcoTTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>m₀</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoTTIDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoTTIDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>ϕ [zeros(Float32,0,0,0)]</code> the symmetry axies azimuth angle counter-clockwise from the x axis, in radians.    Assumed to be zero if not specified. </li><li><code>θ [zeros(Float32,0,0,0)]</code> the symmetry axies tilt angle in radians. Assumed to be zero if not    specified. θ must be an array the same size as buoyancy <code>b</code>. </li><li><code>f [0.85]</code> See the discussion above regarding the <strong>Pseudo-acoustic approximation</strong> used here</li><li><code>srcfieldfile [&quot;field-20458c83-0b07-4064-863c-25e28b935c88.bin&quot;]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, ny_subcubem, nx_subcube [32]</code> The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.</li><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sy [0.0]</code> Array of source Y coordinate.</li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>ry [[0.0]]</code> 2D array of receiver Y coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>y0 [0.0]</code> Origin of physical coordinates for the Y dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dy [10.0]</code> Spacing of physical coordinates in the Y dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFDFDFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFDFDFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFDFDFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, pady, padx [0.0], [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nby_cache, nbx_cache [512], [8], [8]</code> The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nby_inject, nbx_inject = [16], [16], [16]</code> The number of blocks in the Z, Y, and X    dimensions for threading the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop3DAcoTTIDenQ_DEO2_FDTD.jl#L182-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.JopNlProp3DAcoVTIDenQ_DEO2_FDTD-Tuple{}" href="#JetPackWaveFD.JopNlProp3DAcoVTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp3DAcoVTIDenQ_DEO2_FDTD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; kwargs...)
JopLnProp3DAcoVTIDenQ_DEO2_FDTD(; m₀, kwargs...)</code></pre><p>Create a <code>Jets</code> nonlinear or linearized operator for 3D pseudo- visco-acoustic, vertical transverse isotropy,  variable density modeling.</p><p><strong>Model Parameters</strong></p><p>This propagator operates with four model parameters, as shown in the table below.</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: left">P wave velocity</td></tr><tr><td style="text-align: center"><code>ϵ</code></td><td style="text-align: left">Modified Thomsen&#39;s weak anisotropy parameter</td></tr><tr><td style="text-align: center"><code>η</code></td><td style="text-align: left">Modified Alkhalifah&#39;s weak anisotropy parameter η</td></tr><tr><td style="text-align: center"><code>b</code></td><td style="text-align: left">buoyancy (reciprocal density)</td></tr></table><p><strong>Pseudo-acoustic approximation</strong></p><p>With the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter <code>f</code> representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah&#39;s weak anisotropy parameter <code>η</code>. We show formulas for these two parameters below.  The parameter <code>f</code> is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.</p><ul><li><code>η = sqrt[2(ϵ-δ)/(f+2ϵ)]</code></li><li><code>f = 1 - Vₛ² / Vₚ²</code></li></ul><p>For more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. </p><p><strong>Active and passive model parameters</strong></p><p>There are two modes of operation that define different sets of <strong>active</strong> and <strong>passive</strong> parameters,  <em>velocity only</em> and <em>velocity and anisotropy</em>. </p><p>An <strong>active</strong> parameter can be inverted for using the Jacobian linearized operator machinery,   and a <strong>passive</strong> parameter is constant. The two modes are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Active Parameters</th><th style="text-align: left">Passive Parameters</th></tr><tr><td style="text-align: left">velocity only</td><td style="text-align: left">[<code>v</code>]</td><td style="text-align: left">[<code>ϵ</code>, <code>η</code>, <code>b</code>]</td></tr><tr><td style="text-align: left">velocity and anisotropy</td><td style="text-align: left">[<code>v</code>, <code>ϵ</code>, <code>η</code>]</td><td style="text-align: left">[<code>b</code>]</td></tr></table><p>To make a parameter <strong>passive</strong>, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are <em>not</em> passed to the constructor are assumed to be <strong>active</strong>, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  <code>[Z coord][X coord][Active Parameter]</code></p><p><strong>Examples</strong></p><p><strong>Model and acquisition geometry setup</strong></p><ol><li>load modules Jets, WaveFD, and JetPackWaveFD</li><li>set up the model discretization, coordinate size and spacing</li><li>set up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet</li><li>create constant models for <code>v</code>, <code>ϵ</code>, <code>η</code>, <code>b</code></li></ol><pre><code class="language-none">using Jets, WaveFD, JetPackWaveFD
nz,ny,nx = 100, 80, 60                        # spatial discretization size
dz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling
ntrec = 1101                                  # number of temporal samples in recorded data
dtrec = 0.0100                                # sample rate for recorded data
dtmod = 0.0025                                # sample rate for modeled data
wavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) 
sz = dz                                       # source Z location 
sy = dy*(ny/2)                                # source Y location 
sx = dx*(nx/2)                                # source X location 
rz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations 
ry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations
rx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations
b = ones(Float32, nz, ny, nx);                # constant buoyancy
ϵ = 0.1 * ones(Float32, nz, ny, nx);          # constant epsilon
η = 0.2 * ones(Float32, nz, ny, nx);          # constant eta</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v</code> is active; <code>ϵ, η, b</code> are passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the constant velocity model m₀ </li><li>perform nonlinear forward modeling with constant velocity model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the nonlinear operator (<code>v, ϵ, η</code> are active; <code>b</code> is passive)</strong></p><ol><li>create the nonlinear operator <code>F</code></li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>perform nonlinear forward modeling with model <code>m₀</code> and return the resulting modeled data in <code>d</code></li></ol><pre><code class="language-none">F = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
d = F*m₀;              # forward nonlinear op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 1)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b</code> is passive.</p><ol><li>create the nonlinear operator <code>F</code> directly by construction of a jet. </li><li>create the model vector and set parameters <code>v, ϵ, η</code></li><li>create the Jacobian operator <code>J</code> by linearization of <code>F</code> at point <code>m₀</code> </li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><p>Note that the Jacobian operators <code>J</code> and <code>J&#39;</code> require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.</p><pre><code class="language-none">F = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, 
    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, 
    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)
m₀ = zeros(domain(F));
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
J = jacobian(F, m₀)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Construct and apply the linearized Jacobian operator (method 2)</strong></p><p>For this example we assume in the model that <code>v, ϵ, η</code> are active parameters, and <code>b</code> is passive.</p><ol><li>create the constant velocity model m₀ </li><li>create the Jacobian operator <code>J</code> at point <code>m₀</code> directly by construction of a jet.</li><li>create a random model perturbation vector <code>δm</code>.</li><li>perform linearized forward (Born) modeling on the model perturbation vector <code>δm</code> and   return the resulting data perturbation in <code>δd</code>.</li><li>perform linearized adjoint (Born) migration on the data perturbation vector <code>δd</code> and   return the resulting model perturbation in <code>δm</code>. </li></ol><pre><code class="language-none">m₀ = zeros(Float32, nz, ny, nx, 3);
m₀[:,:,:,1] .= 1500;
m₀[:,:,:,2] .= 0.1;
m₀[:,:,:,3] .= 0.2;
J = JopLnProp3DAcoVTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, isinterior=true, nsponge = 10, 
    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, 
    wavelet = wavelet, sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)
δm = rand(domain(J));
δd = J*δm;             # forward linearized op
δm = J&#39;*δd;            # adjoint linearized op</code></pre><p><strong>Required Parameters</strong></p><ul><li><code>m₀</code> the point at which the jet is linearized. Note this argument is required in the constuctor for     <code>JopLnProp2DAcoVTIDenQ_DEO2_FDTD</code> but not <code>JopNlProp2DAcoVTIDenQ_DEO2_FDTD</code>. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.</li><li><code>dtmod</code> The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: <code>dt = 0.75 * 0.38 * max(dx,dz) / maximum(v)</code>. Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified <em>heuristically</em> to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.</li><li><code>dtrec</code> The number of time samples in the recorded data. Note requirement that <code>dtrec</code>    be an even multiple of <code>dtmod</code>.</li><li><code>ntrec</code> The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from <code>ntrec</code>, <code>dtrec</code>, and <code>dtmod</code>.</li></ul><p><strong>Optional Parameters</strong></p><p>Defaults for arguments are shown inside square brackets.</p><ul><li><code>b [ones(Float32,0,0,0)]</code> the buoyancy (reciprocal density) array.</li><li><code>f [0.85]</code> See the discussion above regarding the <strong>Pseudo-acoustic approximation</strong> used here</li><li><code>srcfieldfile [joinpath(tempdir(), &quot;field-1664bcbe-3b6f-41dc-935d-f56d29505bde.bin&quot;)]</code> the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. </li><li><code>comptype [nothing]</code> the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:<ul><li><code>nothing</code> - no compression.</li><li><code>Float32</code> - if wavefield is <code>Float64</code>, then do a simple conversion to Float32.</li><li><code>UInt32</code> - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).</li></ul></li><li><code>compscale [1e-2]</code> determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Smaller values mean more aggressive thresholding.</li><li><code>nz_subcube, ny_subcubem, nx_subcube [32]</code> The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with <code>CvxCompress</code>. Note the requirement   <code>[8 &lt;= n*_subcube &lt;=256]</code>.</li><li><code>isinterior [false]</code> boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with <code>isinterior = true</code>, but    the linearization correctness test may fail.<ul><li><code>true</code> the entire model including absorbing boundaries is serialized and deserialized</li><li><code>false</code> the interior part of the model excluding absorbing boundaries is serialized    and deserialized</li></ul></li><li><code>sz [0.0]</code> Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. </li><li><code>sy [0.0]</code> Array of source Y coordinate.</li><li><code>sx [0.0]</code> Array of source X coordinate.</li><li><code>st [0.0]</code> Array of source delay times.</li><li><code>interpmethod [:hicks]</code> Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. <code>interpmethod</code> must be one of:<ul><li><code>:hicks</code> Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)</li><li><code>:linear</code> bilinear interpolation (up to 2x2x2 nonzero points per location)</li></ul></li><li><code>rz [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>ry [[0.0]]</code> 2D array of receiver Y coordinates</li><li><code>rx [[0.0]]</code> 2D array of receiver Z coordinates</li><li><code>z0 [0.0]</code> Origin of physical coordinates for the Z dimension.</li><li><code>y0 [0.0]</code> Origin of physical coordinates for the Y dimension.</li><li><code>x0 [0.0]</code> Origin of physical coordinates for the X dimension.</li><li><code>dz [10.0]</code> Spacing of physical coordinates in the Z dimension.</li><li><code>dy [10.0]</code> Spacing of physical coordinates in the Y dimension.</li><li><code>dx [10.0]</code> Spacing of physical coordinates in the X dimension.</li><li><code>freqQ [5.0]</code> The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qMin [0.1]</code> The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>qInterior [100.0]</code> the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see <code>JetPackWaveFD</code> package documentation for more information concerning the attenuation model.   </li><li><code>padz, pady, padx [0.0], [0.0], [0.0]</code> - apply extra padding to the survey determined aperture in <code>Ginsu</code>.   Please see <code>Ginsu</code> for more information. </li><li><code>nbz_cache, nby_cache, nbx_cache [512], [8], [8]</code> The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. </li><li><code>nbz_inject, nby_inject, nbx_inject = [16], [16], [16]</code> The number of blocks in the Z, Y, and X    dimensions for threading the wavefield injection.</li><li><code>nsponge [50]</code> The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be &gt; 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. </li><li><code>wavelet [WaveletCausalRicker(f=5.0)]</code> The source wavelet, can be specified as either a Wavelet type    or an array.</li><li><code>freesurface [false]</code> Determines if a free surface (<code>true</code>) or absorbing (<code>false</code>) top boundary condition   is applied.</li><li><code>nthreads [Sys.CPU_THREADS]</code> The number of threads to use for OpenMP parallelization of the modeling.</li><li><code>reportinterval [500]</code> The interval at which information about the propagtion is logged.</li></ul><p>See also: <code>Ginsu</code>, <code>WaveletSine</code>, <code>WaveletRicker</code>, <code>WaveletMinPhaseRicker</code>, <code>WaveletDerivRicker</code>,      <code>WaveletCausalRicker</code>, <code>WaveletOrmsby</code>, <code>WaveletMinPhaseOrmsby</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/jop_prop3DAcoVTIDenQ_DEO2_FDTD.jl#L176-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.interior-Union{Tuple{N}, Tuple{T}, Tuple{Ginsu{N,JA,JB,JC,JD} where JD where JC where JB where JA,AbstractArray{T,N}}} where N where T" href="#JetPackWaveFD.interior-Union{Tuple{N}, Tuple{T}, Tuple{Ginsu{N,JA,JB,JC,JD} where JD where JC where JB where JA,AbstractArray{T,N}}} where N where T"><code>JetPackWaveFD.interior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mi = interior(ginsu, mg)</code></pre><p>Get a view of the Ginsu&#39;d subset <code>mg</code> corresponding to its interior region which excludes the sponge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/ginsu.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.srcillum!-Tuple{AbstractArray,Jets.Jop}" href="#JetPackWaveFD.srcillum!-Tuple{AbstractArray,Jets.Jop}"><code>JetPackWaveFD.srcillum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">srcillum(J)
srcillum(J, m)
srcillum!(y, J, m)</code></pre><p>Compute and return the source illumination for <code>Jets</code> operator <code>J</code>. The source illumination  is defined as the sum of squares of the wavefield amplitudes everywhere in the model over  the time of the finite difference evolution. </p><p>If <code>J::Jop</code> is a <code>Jets</code> block operator or distributed block operator, the source  illuminations from all blocks will be accumulated with a simple sum.</p><p><code>srcillum(J)</code> creates and returns an array with the source illumination from <code>J::Jop</code>,  using the current location defined in the <code>Jet</code>.</p><p><code>srcillum(J, m)</code> creates and returns an array with the source illumination from <code>J::Jop</code>  for the location <code>m</code>.</p><p><code>srcillum!(y, J, m)</code> zeros the passed array <code>y</code> and then accumulates to the source  illumination from <code>J::Jop</code> at the location <code>m</code> into <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/illumination.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.srcillum-Tuple{Jets.Jop}" href="#JetPackWaveFD.srcillum-Tuple{Jets.Jop}"><code>JetPackWaveFD.srcillum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">srcillum(J)
srcillum(J, m)
srcillum!(y, J, m)</code></pre><p>Compute and return the source illumination for <code>Jets</code> operator <code>J</code>. The source illumination  is defined as the sum of squares of the wavefield amplitudes everywhere in the model over  the time of the finite difference evolution. </p><p>If <code>J::Jop</code> is a <code>Jets</code> block operator or distributed block operator, the source  illuminations from all blocks will be accumulated with a simple sum.</p><p><code>srcillum(J)</code> creates and returns an array with the source illumination from <code>J::Jop</code>,  using the current location defined in the <code>Jet</code>.</p><p><code>srcillum(J, m)</code> creates and returns an array with the source illumination from <code>J::Jop</code>  for the location <code>m</code>.</p><p><code>srcillum!(y, J, m)</code> zeros the passed array <code>y</code> and then accumulates to the source  illumination from <code>J::Jop</code> at the location <code>m</code> into <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/illumination.jl#L34-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.sub!-Tuple{AbstractArray,Ginsu,AbstractArray}" href="#JetPackWaveFD.sub!-Tuple{AbstractArray,Ginsu,AbstractArray}"><code>JetPackWaveFD.sub!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sub!(mg, ginsu, m; extend=true, interior=false)</code></pre><p>Store the subset of <code>m</code> corresponding to <code>ginsu</code> in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/ginsu.jl#L224-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.sub-Tuple{Ginsu,AbstractArray}" href="#JetPackWaveFD.sub-Tuple{Ginsu,AbstractArray}"><code>JetPackWaveFD.sub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mg = sub(ginsu, m; extend=true, interior=false)</code></pre><p>Store the subset of <code>m</code> corresponding to <code>ginsu</code> in <code>mg</code>.  New memory is allocated for <code>mg</code>.  <code>interior=false</code> includes the sponge region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/ginsu.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.super!-Tuple{AbstractArray,Ginsu,AbstractArray}" href="#JetPackWaveFD.super!-Tuple{AbstractArray,Ginsu,AbstractArray}"><code>JetPackWaveFD.super!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">super!(m, ginsu, mg; interior=false, accumulate=false)</code></pre><p>Store the superset of <code>mg</code> corresponding to <code>ginsu</code> in <code>m</code>. <code>interior=false</code> includes the sponge region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/ginsu.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.Ginsu-Union{Tuple{N}, Tuple{Tuple{Vararg{Real,N}},Tuple{Vararg{Real,N}},Tuple{Vararg{Int64,N}},Tuple{Vararg{AbstractArray{Float64,1},N}},Tuple{Vararg{AbstractArray{Float64,1},N}},Tuple{Vararg{Tuple{Real,Real},N}},Tuple{Vararg{Tuple{Int64,Int64},N}}}} where N" href="#JetPackWaveFD.Ginsu-Union{Tuple{N}, Tuple{Tuple{Vararg{Real,N}},Tuple{Vararg{Real,N}},Tuple{Vararg{Int64,N}},Tuple{Vararg{AbstractArray{Float64,1},N}},Tuple{Vararg{AbstractArray{Float64,1},N}},Tuple{Vararg{Tuple{Real,Real},N}},Tuple{Vararg{Tuple{Int64,Int64},N}}}} where N"><code>JetPackWaveFD.Ginsu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = Ginsu(r0, dr, nr, sour, recr, padr, ndamp; dims=(:z,:y,:x), stencilhalfwidth=2)</code></pre><p>Create a Ginsu object that defines the model aperture for a given shot.  <code>g</code> is used to subset earth  models using the <code>sub</code> and <code>sub!</code> methods, and provides the inverse operation using the <code>super</code>,  <code>super!</code> and <code>super_accumulate!</code> methods.  The padding for the earth model subset is determined  from the source and receiver positions, along with the padding <code>padr</code> and damping region <code>ndamp</code>  parameters.</p><p><strong>required parameters[1,2]</strong></p><ul><li><code>r0::NTuple{N,Real}</code> model origin in each model dimension</li><li><code>dr::NTuple{N,Real}</code> model cell widths in each model dimension</li><li><code>nr::NTuple{N,Int}</code> model cell counts in each model dimension</li><li><code>sour::NTuple{N,Vector{Float}}</code> source locations in each model dimension</li><li><code>recr::NTuple{N,Vector{Float}}</code> receiver locations in each model dimension</li><li><code>padr::NTuple{N,NTuple{Real,Real}}</code> padding beyond the survey aperture in each model dimension[3,4]</li><li><code>ndamp::NTuple{N,NTuple{Int,Int}}</code> damping region for absorbing boundaies in each model dimension[3,4]</li></ul><p><strong>named optional parameters</strong></p><ul><li><code>dim=(:z,:y,:x)</code> axis ordering with the default being <code>z</code> fast, and <code>x</code> slow</li><li><code>stencilhalfwidth=0</code> if there is a free-surface, set <code>stencilhalfwidth</code>, padr, and ndamp accordingly. This will add <code>stencilhalfwidth</code> cells above the free surface to allow copying the mirrored model to implement the free surface boundary condition.</li></ul><p><strong>type specification</strong></p><ul><li><code>g.lextrng</code> is the logical (1-based) indices for the Ginsu model subset</li><li><code>g.lintrng</code> is the logical (1-based) indices for the Ginsu model subset interior</li><li><code>rₒ</code> is the physical origin of the Ginsu model subset</li><li><code>δr</code> is the grid cell sizes</li></ul><p><strong>Notes</strong></p><ol><li><code>N</code> is the number of model dimensions</li><li><code>rₒ[i]</code> is the model origin along the ith model dimension</li><li>the model padding is the combination of <code>padr</code> and <code>ndamp</code></li><li><code>padr[i][1]</code> is the padding for the dimension start, and <code>padr[i][2]</code> for the end.  The same is true for <code>ndamp</code>.</li></ol><p><strong>Example (free-surface)</strong></p><pre><code class="language-none">o---------------c---x--------------x---c-------o
|               |   |              |   |       |
|               |   |              |   |       |
|               |   |              |   |       |
|               |   |              |   |       |
|               |   x--------------x   |       |
|               |                      |       |
o---------------c----------------------c-------o</code></pre><ul><li><code>o</code> denotes the original model</li><li><code>c</code> denotes the Ginsu module subset</li><li><code>x</code> denotes the Ginsu model subset interior</li><li>the region falling in-between the Ginsu model subset and the Ginsu model subset interior is the absorbing boundary region.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/ginsu.jl#L10-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPackWaveFD.Ginsu-Union{Tuple{N}, Tuple{Tuple{Vararg{Real,N}},Tuple{Vararg{Real,N}},Tuple{Vararg{Int64,N}},Tuple{Vararg{AbstractRange,N}},Tuple{Vararg{Tuple{Int64,Int64},N}}}} where N" href="#JetPackWaveFD.Ginsu-Union{Tuple{N}, Tuple{Tuple{Vararg{Real,N}},Tuple{Vararg{Real,N}},Tuple{Vararg{Int64,N}},Tuple{Vararg{AbstractRange,N}},Tuple{Vararg{Tuple{Int64,Int64},N}}}} where N"><code>JetPackWaveFD.Ginsu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = Ginsu(r0, dr, nr, aperturer, ndamp; T=Float32)</code></pre><p>Create a Ginsu object from absolute aperture.</p><p><strong>required parameters[1,2]</strong></p><ul><li><code>aperturer::NTuple{Range}</code> aperture in each dimension</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPackWaveFD.jl/blob/59ac402f50202436f5e12cf4e12fb8b07317108f/src/ginsu.jl#L174-L181">source</a></section></article><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#JetPackWaveFD.Ginsu-Union{Tuple{N}, Tuple{Tuple{Vararg{Real,N}},Tuple{Vararg{Real,N}},Tuple{Vararg{Int64,N}},Tuple{Vararg{AbstractRange,N}},Tuple{Vararg{Tuple{Int64,Int64},N}}}} where N"><code>JetPackWaveFD.Ginsu</code></a></li><li><a href="#JetPackWaveFD.Ginsu-Union{Tuple{N}, Tuple{Tuple{Vararg{Real,N}},Tuple{Vararg{Real,N}},Tuple{Vararg{Int64,N}},Tuple{Vararg{AbstractArray{Float64,1},N}},Tuple{Vararg{AbstractArray{Float64,1},N}},Tuple{Vararg{Tuple{Real,Real},N}},Tuple{Vararg{Tuple{Int64,Int64},N}}}} where N"><code>JetPackWaveFD.Ginsu</code></a></li><li><a href="#JetPackWaveFD.JopLnProp2DAcoIsoDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp2DAcoIsoDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopLnProp2DAcoTTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp2DAcoTTIDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopLnProp2DAcoVTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp2DAcoVTIDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopLnProp3DAcoIsoDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp3DAcoIsoDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopLnProp3DAcoTTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp3DAcoTTIDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopLnProp3DAcoVTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopLnProp3DAcoVTIDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopNlProp2DAcoIsoDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp2DAcoIsoDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopNlProp2DAcoTTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp2DAcoTTIDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopNlProp2DAcoVTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp2DAcoVTIDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopNlProp3DAcoIsoDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp3DAcoIsoDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopNlProp3DAcoTTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp3DAcoTTIDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.JopNlProp3DAcoVTIDenQ_DEO2_FDTD-Tuple{}"><code>JetPackWaveFD.JopNlProp3DAcoVTIDenQ_DEO2_FDTD</code></a></li><li><a href="#JetPackWaveFD.interior-Union{Tuple{N}, Tuple{T}, Tuple{Ginsu{N,JA,JB,JC,JD} where JD where JC where JB where JA,AbstractArray{T,N}}} where N where T"><code>JetPackWaveFD.interior</code></a></li><li><a href="#JetPackWaveFD.srcillum-Tuple{Jets.Jop}"><code>JetPackWaveFD.srcillum</code></a></li><li><a href="#JetPackWaveFD.srcillum!-Tuple{AbstractArray,Jets.Jop}"><code>JetPackWaveFD.srcillum!</code></a></li><li><a href="#JetPackWaveFD.sub-Tuple{Ginsu,AbstractArray}"><code>JetPackWaveFD.sub</code></a></li><li><a href="#JetPackWaveFD.sub!-Tuple{AbstractArray,Ginsu,AbstractArray}"><code>JetPackWaveFD.sub!</code></a></li><li><a href="#JetPackWaveFD.super!-Tuple{AbstractArray,Ginsu,AbstractArray}"><code>JetPackWaveFD.super!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« JetPackWaveFD</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 15 October 2020 16:10">Thursday 15 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
