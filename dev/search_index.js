var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [JetPackWaveFD]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/#JetPackWaveFD.JopLnProp2DAcoIsoDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopLnProp2DAcoIsoDenQ_DEO2_FDTD","text":"JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp2DAcoIsoDenQ_DEO2_FDTD(; v, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 2D visco-acoustic, isotropic,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with two model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nb buoyancy (reciprocal density)\n\nVelocity v and buoyancy b can be active parameters and inverted for using the Jacobian machinery, or passive parameters that are constant. If a parameter is active there will be a component of model assigned to it.\n\nThe model is 3D with the slowest dimension for model parameter.  The earth model property maps to the slow- dimension array index via the state(F).active_modelset dictionary.\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant buoyancy array\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,nx = 200, 100                      # spatial discretization size\ndz,dx = 20.0, 20.0                    # spatial discretization sampling\nntrec = 1101                          # number of temporal samples in recorded data\ndtrec = 0.0100                        # sample rate for recorded data\ndtmod = 0.0025                        # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) \nsz = dz                               # source Z location \nsx = dx*(nx/2)                        # source X location \nrx = dx*[0:0.5:nx-1;];                # array of receiver X locations\nrz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations\nb = ones(Float32, nz, nx);            # buoyancy model (reciprocal density)\n\nConstruct and apply the nonlinear operator\n\ncreate the nonlinear operator F\ncreate the constant velocity model m₀ \nperform nonlinear forward modeling with constant velocity model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, \n    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = 1500 .* ones(domain(F));\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the constant velocity model m₀ \ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, \n    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = 1500 .* ones(domain(F));\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\ncreate the constant velocity model m₀ \ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = 1500 * ones(Float32, nz, nx);\nJ = JopLnProp2DAcoIsoDenQ_DEO2_FDTD(; v = m₀, b = b, ntrec = ntrec, \n    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sx = sx, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nv the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoIsoDenQ_DEO2_FDTD but not JopNlProp2DAcoIsoDenQ_DEO2_FDTD. This constuctor is shown     in the last example above.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0)] the buoyancy (reciprocal density) array.\nsrcfieldfile [joinpath(tempdir(), \"field-6cfcaee0-8faf-4d13-87c1-42b62d251124.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, nx_subcube [32] The Z and X sizes of windows used for compression    of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, padx [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nbx_cache [512], [8] The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM).  \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,     WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopLnProp2DAcoTTIDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopLnProp2DAcoTTIDenQ_DEO2_FDTD","text":"JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp2DAcoTTIDenQ_DEO2_FDTD(; m₀, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 2D pseudo- visco-acoustic, tilted transverse isotropy,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with five model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nϵ Modified Thomsen's weak anisotropy parameter\nη Modified Alkhalifah's weak anisotropy parameter η\nb buoyancy (reciprocal density)\nθ symmetry axis tilt angle from vertical (radians)\n\nPseudo-acoustic approximation\n\nWith the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter f representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah's weak anisotropy parameter η. We show formulas for these two parameters below.  The parameter f is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.\n\nη = sqrt[2(ϵ-δ)/(f+2ϵ)]\nf = 1 - Vₛ² / Vₚ²\n\nFor more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. \n\nActive and passive model parameters\n\nThere are two modes of operation that define different sets of active and passive parameters,  velocity only and velocity and anisotropy. \n\nAn active parameter can be inverted for using the Jacobian linearized operator machinery,   and a passive parameter is constant. The two modes are:\n\nMode Active Parameters Passive Parameters\nvelocity only [v] [ϵ, η, b, θ ]\nvelocity and anisotropy [v, ϵ, η] [b, θ ]\n\nTo make a parameter passive, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are not passed to the constructor are assumed to be active, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  [Z coord][X coord][Active Parameter]\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant models for v, ϵ, η, b, θ\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,nx = 200, 100                      # spatial discretization size\ndz,dx = 20.0, 20.0                    # spatial discretization sampling\nntrec = 1101                          # number of temporal samples in recorded data\ndtrec = 0.0100                        # sample rate for recorded data\ndtmod = 0.0025                        # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) \nsz = dz                               # source Z location \nsx = dx*(nx/2)                        # source X location \nrx = dx*[0:0.5:nx-1;];                # array of receiver X locations\nrz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations\nb = ones(Float32, nz, nx);            # constant buoyancy\nϵ = 0.1 * ones(Float32, nz, nx);      # constant epsilon\nη = 0.2 * ones(Float32, nz, nx);      # constant eta\nθ = (π/8) * ones(Float32, nz, nx);    # constant tilt angle\n\nConstruct and apply the nonlinear operator (v is active; ϵ, η, b, θ are passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameter v\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, θ = θ, ntrec = ntrec, dtrec = dtrec, \n    dtmod = dtmod, dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the nonlinear operator (v, ϵ, η are active; b, θ are passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameters v, ϵ, η\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ntrec = ntrec, dtrec = dtrec, dtmod = dtmod, \n    dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b, θ are passive.\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ntrec = ntrec, dz = dz, dx = dx, \n    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b, θ are passive.\n\ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = zeros(Float32, nz, nx, 3);\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nJ = JopLnProp2DAcoTTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, θ = θ, ntrec = ntrec, dz = dz, dx = dx, \n    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nm₀ the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoTTIDenQ_DEO2_FDTD but not JopNlProp2DAcoTTIDenQ_DEO2_FDTD. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0)] the buoyancy (reciprocal density) array.\nθ [zeros(Float32,0,0)] the symmetry axies tilt angle in radians. Assumed to be zero if not    specified. θ must be an array the same size as buoyancy b. \nf [0.85] See the discussion above regarding the Pseudo-acoustic approximation used here\nsrcfieldfile [joinpath(tempdir(), \"field-dfdc45f8-fd7f-4017-b61a-20b13542094d.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, nx_subcube [32] The Z and X sizes of windows used for compression    of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, padx [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nbx_cache [512], [8] The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopLnProp2DAcoVTIDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopLnProp2DAcoVTIDenQ_DEO2_FDTD","text":"JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp2DAcoVTIDenQ_DEO2_FDTD(; m₀, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 2D pseudo- visco-acoustic, vertical transverse isotropy,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with four model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nϵ Modified Thomsen's weak anisotropy parameter\nη Modified Alkhalifah's weak anisotropy parameter η\nb buoyancy (reciprocal density)\n\nPseudo-acoustic approximation\n\nWith the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter f representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah's weak anisotropy parameter η. We show formulas for these two parameters below.  The parameter f is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.\n\nη = sqrt[2(ϵ-δ)/(f+2ϵ)]\nf = 1 - Vₛ² / Vₚ²\n\nFor more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. \n\nActive and passive model parameters\n\nThere are two modes of operation that define different sets of active and passive parameters,  velocity only and velocity and anisotropy. \n\nAn active parameter can be inverted for using the Jacobian linearized operator machinery,   and a passive parameter is constant. The two modes are:\n\nMode Active Parameters Passive Parameters\nvelocity only [v] [ϵ, η, b]\nvelocity and anisotropy [v, ϵ, η] [b]\n\nTo make a parameter passive, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are not passed to the constructor are assumed to be active, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  [Z coord][X coord][Active Parameter]\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant models for v, ϵ, η, b\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,nx = 200, 100                      # spatial discretization size\ndz,dx = 20.0, 20.0                    # spatial discretization sampling\nntrec = 1101                          # number of temporal samples in recorded data\ndtrec = 0.0100                        # sample rate for recorded data\ndtmod = 0.0025                        # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) \nsz = dz                               # source Z location \nsx = dx*(nx/2)                        # source X location \nrx = dx*[0:0.5:nx-1;];                # array of receiver X locations\nrz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations\nb = ones(Float32, nz, nx);            # constant buoyancy\nϵ = 0.1 * ones(Float32, nz, nx);      # constant epsilon\nη = 0.2 * ones(Float32, nz, nx);      # constant eta\n\nConstruct and apply the nonlinear operator (v is active; ϵ, η, b are passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameter v\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, ntrec = ntrec, dtrec = dtrec, \n    dtmod = dtmod, dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the nonlinear operator (v, ϵ, η are active; b is passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameters v, ϵ, η\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, dtrec = dtrec, dtmod = dtmod,\n    dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b is passive.\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, dz = dz, dx = dx, \n    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b is passive.\n\ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = zeros(Float32, nz, nx, 3);\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nJ = JopLnProp2DAcoVTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, ntrec = ntrec, dz = dz, dx = dx, \n    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nm₀ the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoVTIDenQ_DEO2_FDTD but not JopNlProp2DAcoVTIDenQ_DEO2_FDTD. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0)] the buoyancy (reciprocal density) array.\nf [0.85] See the discussion above regarding the Pseudo-acoustic approximation used here\nsrcfieldfile [joinpath(tempdir(), \"field-1b380d52-c527-4891-9bf7-4d6cca18c731.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, nx_subcube [32] The Z and X sizes of windows used for compression    of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, padx [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nbx_cache [512], [8] The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopLnProp3DAcoIsoDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopLnProp3DAcoIsoDenQ_DEO2_FDTD","text":"JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp3DAcoIsoDenQ_DEO2_FDTD(; v, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 3D visco-acoustic, isotropic,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with two model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nb buoyancy (reciprocal density)\n\nVelocity v and buoyancy b can be active parameters and inverted for using the Jacobian machinery, or passive parameters that are constant. If a parameter is active there will be a component of model assigned to it.\n\nThe model is 4D with the slowest dimension for model parameter.  The earth model property maps to the slow- fimension array index via the state(F).active_modelset dictionary.\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant buoyancy array\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,ny,nx = 100, 80, 60                        # spatial discretization size\ndz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling\nntrec = 1101                                  # number of temporal samples in recorded data\ndtrec = 0.0100                                # sample rate for recorded data\ndtmod = 0.0025                                # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) \nsz = dz                                       # source Z location \nsy = dy*(ny/2)                                # source Y location \nsx = dx*(nx/2)                                # source X location \nrz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations \nry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations\nrx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations\nb = ones(Float32, nz, ny, nx);                # buoyancy model (reciprocal density)\n\nConstruct and apply the nonlinear operator\n\ncreate the nonlinear operator F\ncreate the constant velocity model m₀ \nperform nonlinear forward modeling with constant velocity model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, \n    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = 1500 .* ones(domain(F));\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the constant velocity model m₀ \ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, \n    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = 1500 .* ones(domain(F));\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\ncreate the constant velocity model m₀ \ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = 1500 .* ones(Float32, nz, ny, nx);       # velocity model\nJ = JopLnProp3DAcoIsoDenQ_DEO2_FDTD(; v = m₀, b = b, isinterior=true, nsponge = 10, ntrec = ntrec, \n    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nv the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp3DAcoIsoDenQ_DEO2_FDTD but not JopNlProp3DAcoIsoDenQ_DEO2_FDTD. This constuctor is shown     in the last example above.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0,0)] the buoyancy (reciprocal density) array.\nsrcfieldfile [joinpath(tempdir(), \"field-59488943-5562-4015-a513-48ec318a20ee.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, ny_subcube, nx_subcube [32] The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsy [0.0] Array of source Y coordinate.\nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nry [[0.0]] 2D array of receiver Y coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\ny0 [0.0] Origin of physical coordinates for the Y dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndy [10.0] Spacing of physical coordinates in the Y dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, pady, padx [0.0], [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nby_cache, nbx_cache [512], [8], [8] The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition.\nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopLnProp3DAcoTTIDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopLnProp3DAcoTTIDenQ_DEO2_FDTD","text":"JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp3DAcoTTIDenQ_DEO2_FDTD(; m₀, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 3D pseudo- visco-acoustic, tilted transverse isotropy,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with four model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nϵ Modified Thomsen's weak anisotropy parameter\nη Modified Alkhalifah's weak anisotropy parameter η\nb buoyancy (reciprocal density)\nθ symmetry axis tilt angle from vertical (radians)\nϕ symmetry axis aziumuth angle CCW from x (radians)\n\nPseudo-acoustic approximation\n\nWith the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter f representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah's weak anisotropy parameter η. We show formulas for these two parameters below.  The parameter f is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.\n\nη = sqrt[2(ϵ-δ)/(f+2ϵ)]\nf = 1 - Vₛ² / Vₚ²\n\nFor more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. \n\nActive and passive model parameters\n\nThere are two modes of operation that define different sets of active and passive parameters,  velocity only and velocity and anisotropy. \n\nAn active parameter can be inverted for using the Jacobian linearized operator machinery,   and a passive parameter is constant. The two modes are:\n\nMode Active Parameters Passive Parameters\nvelocity only [v] [ϵ, η, b, θ, ϕ ]\nvelocity and anisotropy [v, ϵ, η] [b, θ, ϕ ]\n\nTo make a parameter passive, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are not passed to the constructor are assumed to be active, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  [Z coord][X coord][Active Parameter]\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFDFDFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant models for v, ϵ, η, b, θ, ϕ\n\nusing Jets, WaveFD, JetPackWaveFDFDFD\nnz,ny,nx = 100, 80, 60                        # spatial discretization size\ndz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling\nntrec = 1101                                  # number of temporal samples in recorded data\ndtrec = 0.0100                                # sample rate for recorded data\ndtmod = 0.0025                                # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) \nsz = dz                                       # source Z location \nsy = dy*(ny/2)                                # source Y location \nsx = dx*(nx/2)                                # source X location \nrz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations \nry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations\nrx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations\nb = ones(Float32, nz, ny, nx);                # constant buoyancy\nϵ = 0.1 * ones(Float32, nz, ny, nx);          # constant epsilon\nη = 0.2 * ones(Float32, nz, ny, nx);          # constant eta\nθ = (π/8) * ones(Float32, nz, ny, nx);        # constant tilt angle\nϕ = (π/3) * ones(Float32, nz, ny, nx);        # constant azimuth angle\n\nConstruct and apply the nonlinear operator (v is active; ϵ, η, b, θ, ϕ are passive)\n\ncreate the nonlinear operator F\ncreate the constant velocity model m₀ \nperform nonlinear forward modeling with constant velocity model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the nonlinear operator (v, ϵ, η are active; b, θ, ϕ are passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameters v, ϵ, η\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b, θ, ϕ are passive.\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b, θ, ϕ are passive.\n\ncreate the constant velocity model m₀ \ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = zeros(Float32, nz, ny, nx, 3);\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nJ = JopLnProp3DAcoTTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nm₀ the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoTTIDenQ_DEO2_FDTD but not JopNlProp2DAcoTTIDenQ_DEO2_FDTD. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0,0)] the buoyancy (reciprocal density) array.\nϕ [zeros(Float32,0,0,0)] the symmetry axies azimuth angle counter-clockwise from the x axis, in radians.    Assumed to be zero if not specified. \nθ [zeros(Float32,0,0,0)] the symmetry axies tilt angle in radians. Assumed to be zero if not    specified. θ must be an array the same size as buoyancy b. \nf [0.85] See the discussion above regarding the Pseudo-acoustic approximation used here\nsrcfieldfile [\"field-3cb81d63-1602-432e-ac8b-a416db1ad72c.bin\"] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, ny_subcube, nx_subcube [32] The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsy [0.0] Array of source Y coordinate.\nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nry [[0.0]] 2D array of receiver Y coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\ny0 [0.0] Origin of physical coordinates for the Y dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndy [10.0] Spacing of physical coordinates in the Y dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFDFDFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFDFDFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFDFDFD package documentation for more information concerning the attenuation model.   \npadz, pady, padx [0.0], [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nby_cache, nbx_cache [512], [8], [8] The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopLnProp3DAcoVTIDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopLnProp3DAcoVTIDenQ_DEO2_FDTD","text":"JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp3DAcoVTIDenQ_DEO2_FDTD(; m₀, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 3D pseudo- visco-acoustic, vertical transverse isotropy,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with four model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nϵ Modified Thomsen's weak anisotropy parameter\nη Modified Alkhalifah's weak anisotropy parameter η\nb buoyancy (reciprocal density)\n\nPseudo-acoustic approximation\n\nWith the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter f representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah's weak anisotropy parameter η. We show formulas for these two parameters below.  The parameter f is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.\n\nη = sqrt[2(ϵ-δ)/(f+2ϵ)]\nf = 1 - Vₛ² / Vₚ²\n\nFor more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. \n\nActive and passive model parameters\n\nThere are two modes of operation that define different sets of active and passive parameters,  velocity only and velocity and anisotropy. \n\nAn active parameter can be inverted for using the Jacobian linearized operator machinery,   and a passive parameter is constant. The two modes are:\n\nMode Active Parameters Passive Parameters\nvelocity only [v] [ϵ, η, b]\nvelocity and anisotropy [v, ϵ, η] [b]\n\nTo make a parameter passive, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are not passed to the constructor are assumed to be active, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  [Z coord][X coord][Active Parameter]\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant models for v, ϵ, η, b\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,ny,nx = 100, 80, 60                        # spatial discretization size\ndz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling\nntrec = 1101                                  # number of temporal samples in recorded data\ndtrec = 0.0100                                # sample rate for recorded data\ndtmod = 0.0025                                # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) \nsz = dz                                       # source Z location \nsy = dy*(ny/2)                                # source Y location \nsx = dx*(nx/2)                                # source X location \nrz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations \nry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations\nrx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations\nb = ones(Float32, nz, ny, nx);                # constant buoyancy\nϵ = 0.1 * ones(Float32, nz, ny, nx);          # constant epsilon\nη = 0.2 * ones(Float32, nz, ny, nx);          # constant eta\n\nConstruct and apply the nonlinear operator (v is active; ϵ, η, b are passive)\n\ncreate the nonlinear operator F\ncreate the constant velocity model m₀ \nperform nonlinear forward modeling with constant velocity model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the nonlinear operator (v, ϵ, η are active; b is passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameters v, ϵ, η\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b is passive.\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, \n    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b is passive.\n\ncreate the constant velocity model m₀ \ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = zeros(Float32, nz, ny, nx, 3);\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nJ = JopLnProp3DAcoVTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nm₀ the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoVTIDenQ_DEO2_FDTD but not JopNlProp2DAcoVTIDenQ_DEO2_FDTD. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0,0)] the buoyancy (reciprocal density) array.\nf [0.85] See the discussion above regarding the Pseudo-acoustic approximation used here\nsrcfieldfile [joinpath(tempdir(), \"field-3e6a7965-227d-40dd-ac5a-544f55d115b1.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, ny_subcube, nx_subcube [32] The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsy [0.0] Array of source Y coordinate.\nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nry [[0.0]] 2D array of receiver Y coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\ny0 [0.0] Origin of physical coordinates for the Y dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndy [10.0] Spacing of physical coordinates in the Y dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, pady, padx [0.0], [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nby_cache, nbx_cache [512], [8], [8] The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopNlProp2DAcoIsoDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopNlProp2DAcoIsoDenQ_DEO2_FDTD","text":"JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp2DAcoIsoDenQ_DEO2_FDTD(; v, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 2D visco-acoustic, isotropic,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with two model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nb buoyancy (reciprocal density)\n\nVelocity v and buoyancy b can be active parameters and inverted for using the Jacobian machinery, or passive parameters that are constant. If a parameter is active there will be a component of model assigned to it.\n\nThe model is 3D with the slowest dimension for model parameter.  The earth model property maps to the slow- dimension array index via the state(F).active_modelset dictionary.\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant buoyancy array\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,nx = 200, 100                      # spatial discretization size\ndz,dx = 20.0, 20.0                    # spatial discretization sampling\nntrec = 1101                          # number of temporal samples in recorded data\ndtrec = 0.0100                        # sample rate for recorded data\ndtmod = 0.0025                        # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) \nsz = dz                               # source Z location \nsx = dx*(nx/2)                        # source X location \nrx = dx*[0:0.5:nx-1;];                # array of receiver X locations\nrz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations\nb = ones(Float32, nz, nx);            # buoyancy model (reciprocal density)\n\nConstruct and apply the nonlinear operator\n\ncreate the nonlinear operator F\ncreate the constant velocity model m₀ \nperform nonlinear forward modeling with constant velocity model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, \n    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = 1500 .* ones(domain(F));\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the constant velocity model m₀ \ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp2DAcoIsoDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, \n    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = 1500 .* ones(domain(F));\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\ncreate the constant velocity model m₀ \ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = 1500 * ones(Float32, nz, nx);\nJ = JopLnProp2DAcoIsoDenQ_DEO2_FDTD(; v = m₀, b = b, ntrec = ntrec, \n    dz = dz, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sx = sx, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nv the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoIsoDenQ_DEO2_FDTD but not JopNlProp2DAcoIsoDenQ_DEO2_FDTD. This constuctor is shown     in the last example above.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0)] the buoyancy (reciprocal density) array.\nsrcfieldfile [joinpath(tempdir(), \"field-6cfcaee0-8faf-4d13-87c1-42b62d251124.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, nx_subcube [32] The Z and X sizes of windows used for compression    of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, padx [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nbx_cache [512], [8] The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM).  \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,     WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopNlProp2DAcoTTIDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopNlProp2DAcoTTIDenQ_DEO2_FDTD","text":"JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp2DAcoTTIDenQ_DEO2_FDTD(; m₀, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 2D pseudo- visco-acoustic, tilted transverse isotropy,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with five model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nϵ Modified Thomsen's weak anisotropy parameter\nη Modified Alkhalifah's weak anisotropy parameter η\nb buoyancy (reciprocal density)\nθ symmetry axis tilt angle from vertical (radians)\n\nPseudo-acoustic approximation\n\nWith the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter f representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah's weak anisotropy parameter η. We show formulas for these two parameters below.  The parameter f is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.\n\nη = sqrt[2(ϵ-δ)/(f+2ϵ)]\nf = 1 - Vₛ² / Vₚ²\n\nFor more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. \n\nActive and passive model parameters\n\nThere are two modes of operation that define different sets of active and passive parameters,  velocity only and velocity and anisotropy. \n\nAn active parameter can be inverted for using the Jacobian linearized operator machinery,   and a passive parameter is constant. The two modes are:\n\nMode Active Parameters Passive Parameters\nvelocity only [v] [ϵ, η, b, θ ]\nvelocity and anisotropy [v, ϵ, η] [b, θ ]\n\nTo make a parameter passive, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are not passed to the constructor are assumed to be active, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  [Z coord][X coord][Active Parameter]\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant models for v, ϵ, η, b, θ\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,nx = 200, 100                      # spatial discretization size\ndz,dx = 20.0, 20.0                    # spatial discretization sampling\nntrec = 1101                          # number of temporal samples in recorded data\ndtrec = 0.0100                        # sample rate for recorded data\ndtmod = 0.0025                        # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) \nsz = dz                               # source Z location \nsx = dx*(nx/2)                        # source X location \nrx = dx*[0:0.5:nx-1;];                # array of receiver X locations\nrz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations\nb = ones(Float32, nz, nx);            # constant buoyancy\nϵ = 0.1 * ones(Float32, nz, nx);      # constant epsilon\nη = 0.2 * ones(Float32, nz, nx);      # constant eta\nθ = (π/8) * ones(Float32, nz, nx);    # constant tilt angle\n\nConstruct and apply the nonlinear operator (v is active; ϵ, η, b, θ are passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameter v\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, θ = θ, ntrec = ntrec, dtrec = dtrec, \n    dtmod = dtmod, dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the nonlinear operator (v, ϵ, η are active; b, θ are passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameters v, ϵ, η\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ntrec = ntrec, dtrec = dtrec, dtmod = dtmod, \n    dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b, θ are passive.\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp2DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ntrec = ntrec, dz = dz, dx = dx, \n    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b, θ are passive.\n\ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = zeros(Float32, nz, nx, 3);\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nJ = JopLnProp2DAcoTTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, θ = θ, ntrec = ntrec, dz = dz, dx = dx, \n    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nm₀ the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoTTIDenQ_DEO2_FDTD but not JopNlProp2DAcoTTIDenQ_DEO2_FDTD. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0)] the buoyancy (reciprocal density) array.\nθ [zeros(Float32,0,0)] the symmetry axies tilt angle in radians. Assumed to be zero if not    specified. θ must be an array the same size as buoyancy b. \nf [0.85] See the discussion above regarding the Pseudo-acoustic approximation used here\nsrcfieldfile [joinpath(tempdir(), \"field-dfdc45f8-fd7f-4017-b61a-20b13542094d.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, nx_subcube [32] The Z and X sizes of windows used for compression    of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, padx [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nbx_cache [512], [8] The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopNlProp2DAcoVTIDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopNlProp2DAcoVTIDenQ_DEO2_FDTD","text":"JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp2DAcoVTIDenQ_DEO2_FDTD(; m₀, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 2D pseudo- visco-acoustic, vertical transverse isotropy,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with four model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nϵ Modified Thomsen's weak anisotropy parameter\nη Modified Alkhalifah's weak anisotropy parameter η\nb buoyancy (reciprocal density)\n\nPseudo-acoustic approximation\n\nWith the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter f representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah's weak anisotropy parameter η. We show formulas for these two parameters below.  The parameter f is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.\n\nη = sqrt[2(ϵ-δ)/(f+2ϵ)]\nf = 1 - Vₛ² / Vₚ²\n\nFor more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. \n\nActive and passive model parameters\n\nThere are two modes of operation that define different sets of active and passive parameters,  velocity only and velocity and anisotropy. \n\nAn active parameter can be inverted for using the Jacobian linearized operator machinery,   and a passive parameter is constant. The two modes are:\n\nMode Active Parameters Passive Parameters\nvelocity only [v] [ϵ, η, b]\nvelocity and anisotropy [v, ϵ, η] [b]\n\nTo make a parameter passive, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are not passed to the constructor are assumed to be active, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  [Z coord][X coord][Active Parameter]\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant models for v, ϵ, η, b\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,nx = 200, 100                      # spatial discretization size\ndz,dx = 20.0, 20.0                    # spatial discretization sampling\nntrec = 1101                          # number of temporal samples in recorded data\ndtrec = 0.0100                        # sample rate for recorded data\ndtmod = 0.0025                        # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)  # type of wavelet to use (source signature) \nsz = dz                               # source Z location \nsx = dx*(nx/2)                        # source X location \nrx = dx*[0:0.5:nx-1;];                # array of receiver X locations\nrz = 2*dz*ones(length(0:0.5:nx-1));   # array of receiver Z locations\nb = ones(Float32, nz, nx);            # constant buoyancy\nϵ = 0.1 * ones(Float32, nz, nx);      # constant epsilon\nη = 0.2 * ones(Float32, nz, nx);      # constant eta\n\nConstruct and apply the nonlinear operator (v is active; ϵ, η, b are passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameter v\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, ntrec = ntrec, dtrec = dtrec, \n    dtmod = dtmod, dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the nonlinear operator (v, ϵ, η are active; b is passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameters v, ϵ, η\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, dtrec = dtrec, dtmod = dtmod,\n    dz = dz, dx = dx, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b is passive.\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp2DAcoVTIDenQ_DEO2_FDTD(; b = b, ntrec = ntrec, dz = dz, dx = dx, \n    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b is passive.\n\ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = zeros(Float32, nz, nx, 3);\nm₀[:,:,1] .= 1500;\nm₀[:,:,2] .= 0.1;\nm₀[:,:,3] .= 0.2;\nJ = JopLnProp2DAcoVTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, ntrec = ntrec, dz = dz, dx = dx, \n    dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, sz = sz, sx = sx, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nm₀ the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoVTIDenQ_DEO2_FDTD but not JopNlProp2DAcoVTIDenQ_DEO2_FDTD. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0)] the buoyancy (reciprocal density) array.\nf [0.85] See the discussion above regarding the Pseudo-acoustic approximation used here\nsrcfieldfile [joinpath(tempdir(), \"field-1b380d52-c527-4891-9bf7-4d6cca18c731.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, nx_subcube [32] The Z and X sizes of windows used for compression    of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 2D sinc interpolation (up to 8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, padx [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nbx_cache [512], [8] The size of cache blocks in the Z and X dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimension is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopNlProp3DAcoIsoDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopNlProp3DAcoIsoDenQ_DEO2_FDTD","text":"JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp3DAcoIsoDenQ_DEO2_FDTD(; v, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 3D visco-acoustic, isotropic,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with two model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nb buoyancy (reciprocal density)\n\nVelocity v and buoyancy b can be active parameters and inverted for using the Jacobian machinery, or passive parameters that are constant. If a parameter is active there will be a component of model assigned to it.\n\nThe model is 4D with the slowest dimension for model parameter.  The earth model property maps to the slow- fimension array index via the state(F).active_modelset dictionary.\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant buoyancy array\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,ny,nx = 100, 80, 60                        # spatial discretization size\ndz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling\nntrec = 1101                                  # number of temporal samples in recorded data\ndtrec = 0.0100                                # sample rate for recorded data\ndtmod = 0.0025                                # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) \nsz = dz                                       # source Z location \nsy = dy*(ny/2)                                # source Y location \nsx = dx*(nx/2)                                # source X location \nrz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations \nry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations\nrx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations\nb = ones(Float32, nz, ny, nx);                # buoyancy model (reciprocal density)\n\nConstruct and apply the nonlinear operator\n\ncreate the nonlinear operator F\ncreate the constant velocity model m₀ \nperform nonlinear forward modeling with constant velocity model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, \n    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = 1500 .* ones(domain(F));\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the constant velocity model m₀ \ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp3DAcoIsoDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, \n    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = 1500 .* ones(domain(F));\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\ncreate the constant velocity model m₀ \ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = 1500 .* ones(Float32, nz, ny, nx);       # velocity model\nJ = JopLnProp3DAcoIsoDenQ_DEO2_FDTD(; v = m₀, b = b, isinterior=true, nsponge = 10, ntrec = ntrec, \n    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nv the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp3DAcoIsoDenQ_DEO2_FDTD but not JopNlProp3DAcoIsoDenQ_DEO2_FDTD. This constuctor is shown     in the last example above.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0,0)] the buoyancy (reciprocal density) array.\nsrcfieldfile [joinpath(tempdir(), \"field-59488943-5562-4015-a513-48ec318a20ee.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, ny_subcube, nx_subcube [32] The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsy [0.0] Array of source Y coordinate.\nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nry [[0.0]] 2D array of receiver Y coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\ny0 [0.0] Origin of physical coordinates for the Y dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndy [10.0] Spacing of physical coordinates in the Y dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, pady, padx [0.0], [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nby_cache, nbx_cache [512], [8], [8] The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition.\nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopNlProp3DAcoTTIDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopNlProp3DAcoTTIDenQ_DEO2_FDTD","text":"JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp3DAcoTTIDenQ_DEO2_FDTD(; m₀, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 3D pseudo- visco-acoustic, tilted transverse isotropy,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with four model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nϵ Modified Thomsen's weak anisotropy parameter\nη Modified Alkhalifah's weak anisotropy parameter η\nb buoyancy (reciprocal density)\nθ symmetry axis tilt angle from vertical (radians)\nϕ symmetry axis aziumuth angle CCW from x (radians)\n\nPseudo-acoustic approximation\n\nWith the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter f representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah's weak anisotropy parameter η. We show formulas for these two parameters below.  The parameter f is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.\n\nη = sqrt[2(ϵ-δ)/(f+2ϵ)]\nf = 1 - Vₛ² / Vₚ²\n\nFor more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. \n\nActive and passive model parameters\n\nThere are two modes of operation that define different sets of active and passive parameters,  velocity only and velocity and anisotropy. \n\nAn active parameter can be inverted for using the Jacobian linearized operator machinery,   and a passive parameter is constant. The two modes are:\n\nMode Active Parameters Passive Parameters\nvelocity only [v] [ϵ, η, b, θ, ϕ ]\nvelocity and anisotropy [v, ϵ, η] [b, θ, ϕ ]\n\nTo make a parameter passive, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are not passed to the constructor are assumed to be active, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  [Z coord][X coord][Active Parameter]\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFDFDFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant models for v, ϵ, η, b, θ, ϕ\n\nusing Jets, WaveFD, JetPackWaveFDFDFD\nnz,ny,nx = 100, 80, 60                        # spatial discretization size\ndz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling\nntrec = 1101                                  # number of temporal samples in recorded data\ndtrec = 0.0100                                # sample rate for recorded data\ndtmod = 0.0025                                # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) \nsz = dz                                       # source Z location \nsy = dy*(ny/2)                                # source Y location \nsx = dx*(nx/2)                                # source X location \nrz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations \nry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations\nrx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations\nb = ones(Float32, nz, ny, nx);                # constant buoyancy\nϵ = 0.1 * ones(Float32, nz, ny, nx);          # constant epsilon\nη = 0.2 * ones(Float32, nz, ny, nx);          # constant eta\nθ = (π/8) * ones(Float32, nz, ny, nx);        # constant tilt angle\nϕ = (π/3) * ones(Float32, nz, ny, nx);        # constant azimuth angle\n\nConstruct and apply the nonlinear operator (v is active; ϵ, η, b, θ, ϕ are passive)\n\ncreate the nonlinear operator F\ncreate the constant velocity model m₀ \nperform nonlinear forward modeling with constant velocity model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the nonlinear operator (v, ϵ, η are active; b, θ, ϕ are passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameters v, ϵ, η\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b, θ, ϕ are passive.\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp3DAcoTTIDenQ_DEO2_FDTD(; b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b, θ, ϕ are passive.\n\ncreate the constant velocity model m₀ \ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = zeros(Float32, nz, ny, nx, 3);\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nJ = JopLnProp3DAcoTTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, θ = θ, ϕ = ϕ, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nm₀ the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoTTIDenQ_DEO2_FDTD but not JopNlProp2DAcoTTIDenQ_DEO2_FDTD. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0,0)] the buoyancy (reciprocal density) array.\nϕ [zeros(Float32,0,0,0)] the symmetry axies azimuth angle counter-clockwise from the x axis, in radians.    Assumed to be zero if not specified. \nθ [zeros(Float32,0,0,0)] the symmetry axies tilt angle in radians. Assumed to be zero if not    specified. θ must be an array the same size as buoyancy b. \nf [0.85] See the discussion above regarding the Pseudo-acoustic approximation used here\nsrcfieldfile [\"field-3cb81d63-1602-432e-ac8b-a416db1ad72c.bin\"] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, ny_subcube, nx_subcube [32] The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsy [0.0] Array of source Y coordinate.\nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nry [[0.0]] 2D array of receiver Y coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\ny0 [0.0] Origin of physical coordinates for the Y dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndy [10.0] Spacing of physical coordinates in the Y dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFDFDFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFDFDFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFDFDFD package documentation for more information concerning the attenuation model.   \npadz, pady, padx [0.0], [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nby_cache, nbx_cache [512], [8], [8] The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.JopNlProp3DAcoVTIDenQ_DEO2_FDTD-Tuple{}","page":"Reference","title":"JetPackWaveFD.JopNlProp3DAcoVTIDenQ_DEO2_FDTD","text":"JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; kwargs...)\nJopLnProp3DAcoVTIDenQ_DEO2_FDTD(; m₀, kwargs...)\n\nCreate a Jets nonlinear or linearized operator for 3D pseudo- visco-acoustic, vertical transverse isotropy,  variable density modeling.\n\nModel Parameters\n\nThis propagator operates with four model parameters, as shown in the table below.\n\nParameter Description\nv P wave velocity\nϵ Modified Thomsen's weak anisotropy parameter\nη Modified Alkhalifah's weak anisotropy parameter η\nb buoyancy (reciprocal density)\n\nPseudo-acoustic approximation\n\nWith the pseudo-acoustic approximation we employ, the transformation to self-adjoint form requires a  parameter f representing the average ratio of shear-wave to p-wave velocity, and a modfication  to Alkhalifah's weak anisotropy parameter η. We show formulas for these two parameters below.  The parameter f is specified as a scalar for the entire model, with default value 0.85, implying a shear velocity around 38% of the p wave velocity.\n\nη = sqrt[2(ϵ-δ)/(f+2ϵ)]\nf = 1 - Vₛ² / Vₚ²\n\nFor more information about the pseudo-acoustic approximation we employ please see  https://library.seg.org/doi/10.1190/segam2016-13878451.1. \n\nActive and passive model parameters\n\nThere are two modes of operation that define different sets of active and passive parameters,  velocity only and velocity and anisotropy. \n\nAn active parameter can be inverted for using the Jacobian linearized operator machinery,   and a passive parameter is constant. The two modes are:\n\nMode Active Parameters Passive Parameters\nvelocity only [v] [ϵ, η, b]\nvelocity and anisotropy [v, ϵ, η] [b]\n\nTo make a parameter passive, you pass the array for that parameter in the constructor for the  operator, implying that it is in state and does not change with the action of the operator.  Parameters that are not passed to the constructor are assumed to be active, and will be part  of the model that the operator acts on, stored as a 3D array with the following indices:  [Z coord][X coord][Active Parameter]\n\nExamples\n\nModel and acquisition geometry setup\n\nload modules Jets, WaveFD, and JetPackWaveFD\nset up the model discretization, coordinate size and spacing\nset up the acquisition geometry, including the time discretization, locations for source and receivers, and the source wavelet\ncreate constant models for v, ϵ, η, b\n\nusing Jets, WaveFD, JetPackWaveFD\nnz,ny,nx = 100, 80, 60                        # spatial discretization size\ndz,dy,dx = 20.0, 20.0, 20.0                   # spatial discretization sampling\nntrec = 1101                                  # number of temporal samples in recorded data\ndtrec = 0.0100                                # sample rate for recorded data\ndtmod = 0.0025                                # sample rate for modeled data\nwavelet = WaveletCausalRicker(f=5.0)          # type of wavelet to use (source signature) \nsz = dz                                       # source Z location \nsy = dy*(ny/2)                                # source Y location \nsx = dx*(nx/2)                                # source X location \nrz = [dz for iy = 1:ny, ix = 1:nx][:];        # Array of receiver Y locations \nry = [(iy-1)*dy for iy = 1:ny, ix = 1:nx][:]; # Array of receiver Y locations\nrx = [(ix-1)*dx for iy = 1:ny, ix=1:nx][:];   # Array of receiver X locations\nb = ones(Float32, nz, ny, nx);                # constant buoyancy\nϵ = 0.1 * ones(Float32, nz, ny, nx);          # constant epsilon\nη = 0.2 * ones(Float32, nz, ny, nx);          # constant eta\n\nConstruct and apply the nonlinear operator (v is active; ϵ, η, b are passive)\n\ncreate the nonlinear operator F\ncreate the constant velocity model m₀ \nperform nonlinear forward modeling with constant velocity model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, ϵ = ϵ, η = η, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the nonlinear operator (v, ϵ, η are active; b is passive)\n\ncreate the nonlinear operator F\ncreate the model vector and set parameters v, ϵ, η\nperform nonlinear forward modeling with model m₀ and return the resulting modeled data in d\n\nF = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nd = F*m₀;              # forward nonlinear op\n\nConstruct and apply the linearized Jacobian operator (method 1)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b is passive.\n\ncreate the nonlinear operator F directly by construction of a jet. \ncreate the model vector and set parameters v, ϵ, η\ncreate the Jacobian operator J by linearization of F at point m₀ \ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nNote that the Jacobian operators J and J' require the serialized nonlinear forward wavefield,  and this is generated automatically whenever required. If you watch the logging to standard out from this example, you will first see the finite difference evolution for the nonlinear forward,  followed by the linearized forward, and finally the linearized adjoint.\n\nF = JopNlProp3DAcoVTIDenQ_DEO2_FDTD(; b = b, isinterior=true, nsponge = 10, ntrec = ntrec, \n    dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, wavelet = wavelet, \n    sz = sz, sy = sy, sx = sx, rz = rz, ry = ry, rx = rx)\nm₀ = zeros(domain(F));\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nJ = jacobian(F, m₀)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nConstruct and apply the linearized Jacobian operator (method 2)\n\nFor this example we assume in the model that v, ϵ, η are active parameters, and b is passive.\n\ncreate the constant velocity model m₀ \ncreate the Jacobian operator J at point m₀ directly by construction of a jet.\ncreate a random model perturbation vector δm.\nperform linearized forward (Born) modeling on the model perturbation vector δm and   return the resulting data perturbation in δd.\nperform linearized adjoint (Born) migration on the data perturbation vector δd and   return the resulting model perturbation in δm. \n\nm₀ = zeros(Float32, nz, ny, nx, 3);\nm₀[:,:,:,1] .= 1500;\nm₀[:,:,:,2] .= 0.1;\nm₀[:,:,:,3] .= 0.2;\nJ = JopLnProp3DAcoVTIDenQ_DEO2_FDTD(; m₀ = m₀, b = b, isinterior=true, nsponge = 10, \n    ntrec = ntrec, dz = dz, dy = dy, dx = dx, dtrec = dtrec, dtmod = dtmod, \n    wavelet = wavelet, sz = sz, sy = sy, sx = sx, ry = ry, rz = rz, rx = rx)\nδm = rand(domain(J));\nδd = J*δm;             # forward linearized op\nδm = J'*δd;            # adjoint linearized op\n\nRequired Parameters\n\nm₀ the point at which the jet is linearized. Note this argument is required in the constuctor for     JopLnProp2DAcoVTIDenQ_DEO2_FDTD but not JopNlProp2DAcoVTIDenQ_DEO2_FDTD. This constuctor is shown     in the last example above. Please note that you must consider which parameters are active and passive,   per the discussion on model parameters above and examples.\ndtmod The sample rate for the modeled data. You can establish a lower bound for the modeling sample rate     with the following expression: dt = 0.75 * 0.38 * max(dx,dz) / maximum(v). Note that the usual     Courant–Friedrichs–Lewy condition (CFL condition) for stability in finite difference modeling is     modified heuristically to include the impact of the visco-acoustic implementation of this operator,     requiring a 25% smaller smaple rate.\ndtrec The number of time samples in the recorded data. Note requirement that dtrec    be an even multiple of dtmod.\nntrec The number of time samples in the recorded data. Note that the number of samples in the modeled     data is determined from ntrec, dtrec, and dtmod.\n\nOptional Parameters\n\nDefaults for arguments are shown inside square brackets.\n\nb [ones(Float32,0,0,0)] the buoyancy (reciprocal density) array.\nf [0.85] See the discussion above regarding the Pseudo-acoustic approximation used here\nsrcfieldfile [joinpath(tempdir(), \"field-3e6a7965-227d-40dd-ac5a-544f55d115b1.bin\")] the full path to a scratch file used for    the serializationof the compressed nonlinear source wavefield. \ncomptype [nothing] the type of compression to use for the serialization of   the nonlinear source wavefield. The type of compression must be one of:\nnothing - no compression.\nFloat32 - if wavefield is Float64, then do a simple conversion to Float32.\nUInt32 - compression using CvxCompress (windowing + 2D wavelet transform +    thresholding + quantization + run-length-encoding).\ncompscale [1e-2] determines the thresholding for the compression of the nonlinear source    wavefield prior to serialization. Larger values mean more aggressive compression. You can    likely increase compscale to 1.0 before you start to notice differences in output from    Jacobian operations. \nnz_subcube, ny_subcube, nx_subcube [32] The Z, Y, and X sizes of windows used for    compression of the nonlinear source wavefield with CvxCompress. Note the requirement   [8 <= n*_subcube <=256].\nisinterior [false] boolean flag that indicates how the nonlinear source wavefield is   saved. For large models, operation will be faster with isinterior = true, but    the linearization correctness test may fail.\ntrue the entire model including absorbing boundaries is serialized and deserialized\nfalse the interior part of the model excluding absorbing boundaries is serialized    and deserialized\nsz [0.0] Array of source Z coordinate. Note that if multiple sources are provided,    they will will be injected simultaneously during finite difference evolution. \nsy [0.0] Array of source Y coordinate.\nsx [0.0] Array of source X coordinate.\nst [0.0] Array of source delay times.\ninterpmethod [:hicks] Type of physical interpolation for sources and receivers. For locations    that are not on the physical grid coordinates, interpolation is used either to inject or extract   information. interpmethod must be one of:\n:hicks Hicks 3D sinc interpolation (up to 8x8x8 nonzero points per location)\n:linear bilinear interpolation (up to 2x2x2 nonzero points per location)\nrz [[0.0]] 2D array of receiver Z coordinates\nry [[0.0]] 2D array of receiver Y coordinates\nrx [[0.0]] 2D array of receiver Z coordinates\nz0 [0.0] Origin of physical coordinates for the Z dimension.\ny0 [0.0] Origin of physical coordinates for the Y dimension.\nx0 [0.0] Origin of physical coordinates for the X dimension.\ndz [10.0] Spacing of physical coordinates in the Z dimension.\ndy [10.0] Spacing of physical coordinates in the Y dimension.\ndx [10.0] Spacing of physical coordinates in the X dimension.\nfreqQ [5.0] The center frequency for the Maxwell body approximation to dissipation only attenuation.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqMin [0.1] The minimum value for Qp at the boundary of the model used in our Maxwell body approximation   to dissipation only attenuation. This is not a physically meaningful value for Qp, as we use the    attenuation to implement absorbing boundary conditions and eliminate outgoing waves on the    boundaries of the computational domain.    Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \nqInterior [100.0] the value for Qp in the interior of the model used in our Maxwell body approximation   to dissipation only attenuation. This is the value for Qp away from the absorbing boundaries and is    a physically meaningful value.   Please see JetPackWaveFD package documentation for more information concerning the attenuation model.   \npadz, pady, padx [0.0], [0.0], [0.0] - apply extra padding to the survey determined aperture in Ginsu.   Please see Ginsu for more information. \nnbz_cache, nby_cache, nbx_cache [512], [8], [8] The size of cache blocks in the Z, X, and Y dimensions.    In general the cache block in the Z (fast) dimension should be ≥ the entire size of that dimension,    and the cache block size in the slower dimensions is generally small in order to allow the entire   block to fit in cache. \nnsponge [50] The number of grid cells to use for the absorbing boundary. For high fidelity modeling   this should be > 60 grid points, but can be significantly smaller for some use cases like low frequency    full waveform inversion. \nwavelet [WaveletCausalRicker(f=5.0)] The source wavelet, can be specified as either a Wavelet type    or an array.\nfreesurface [false] Determines if a free surface (true) or absorbing (false) top boundary condition   is applied.\nimgcondition [\"standard\"] Selects the type of imaging condition used. Choose from \"standard\", \"FWI\",    and \"RTM\". \"FWI\" and \"RTM\" will perform Kz wavenumber filtering prior to the imaging condition   in order to promote long wavelengths (for FWI), or remove long wavelength backscattered energy (for    RTM). \"MIX\" mixes the FWI imaging condition using the parameter RTM_weight. Note the true adjoint    only exists for \"standard\" imaging condition currently.\nRTM_weight [0.5] determines the balance of short wavelengths and long wavelengths in the imaging condition.    A value of 0.0 is equivalent to the FWI imaging condition, a value of 0.5 is equivalent to the standard   imaging condtion, and a value of 1.0 is equivalent to the RTM imaging condition. \nnthreads [Sys.CPU_THREADS] The number of threads to use for OpenMP parallelization of the modeling.\nreportinterval [500] The interval at which information about the propagtion is logged.\n\nSee also: Ginsu, WaveletSine, WaveletRicker, WaveletMinPhaseRicker, WaveletDerivRicker,      WaveletCausalRicker, WaveletOrmsby, WaveletMinPhaseOrmsby \n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.interior-Union{Tuple{Ginsu{N}}, Tuple{N}} where N","page":"Reference","title":"JetPackWaveFD.interior","text":"I = interior(ginsu)\n\nGet the index range corresponding to the interior region which excludes the sponge.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.interior-Union{Tuple{N}, Tuple{T}, Tuple{Ginsu{N}, AbstractArray{T, N}}} where {T, N}","page":"Reference","title":"JetPackWaveFD.interior","text":"mi = interior(ginsu, mg)\n\nGet a view of the Ginsu'd subset mg corresponding to its interior region which excludes the sponge.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.srcillum!-Tuple{AbstractArray, Jets.Jop}","page":"Reference","title":"JetPackWaveFD.srcillum!","text":"srcillum(J)\nsrcillum(J, m)\nsrcillum!(y, J, m)\n\nCompute and return the source illumination for Jets operator J. The source illumination  is defined as the sum of squares of the wavefield amplitudes everywhere in the model over  the time of the finite difference evolution. \n\nIf J::Jop is a Jets block operator or distributed block operator, the source  illuminations from all blocks will be accumulated with a simple sum.\n\nsrcillum(J) creates and returns an array with the source illumination from J::JopLn,  using the current location defined in the Jet.\n\nsrcillum(J, m) creates and returns an array with the source illumination from J::Jop  for the location m.\n\nsrcillum!(y, J, m) zeros the passed array y and then accumulates to the source  illumination from J::Jop at the location m into y.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.srcillum-Tuple{Jets.JopLn}","page":"Reference","title":"JetPackWaveFD.srcillum","text":"srcillum(J)\nsrcillum(J, m)\nsrcillum!(y, J, m)\n\nCompute and return the source illumination for Jets operator J. The source illumination  is defined as the sum of squares of the wavefield amplitudes everywhere in the model over  the time of the finite difference evolution. \n\nIf J::Jop is a Jets block operator or distributed block operator, the source  illuminations from all blocks will be accumulated with a simple sum.\n\nsrcillum(J) creates and returns an array with the source illumination from J::JopLn,  using the current location defined in the Jet.\n\nsrcillum(J, m) creates and returns an array with the source illumination from J::Jop  for the location m.\n\nsrcillum!(y, J, m) zeros the passed array y and then accumulates to the source  illumination from J::Jop at the location m into y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.sub!-Tuple{AbstractArray, Ginsu, AbstractArray}","page":"Reference","title":"JetPackWaveFD.sub!","text":"sub!(mg, ginsu, m; extend=true, interior=false)\n\nStore the subset of m corresponding to ginsu in mg.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.sub-Tuple{Ginsu, AbstractArray}","page":"Reference","title":"JetPackWaveFD.sub","text":"mg = sub(ginsu, m; extend=true, interior=false)\n\nStore the subset of m corresponding to ginsu in mg.  New memory is allocated for mg.  interior=false includes the sponge region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.super!-Tuple{AbstractArray, Ginsu, AbstractArray}","page":"Reference","title":"JetPackWaveFD.super!","text":"super!(m, ginsu, mg; interior=false, accumulate=false)\n\nStore the superset of mg corresponding to ginsu in m. interior=false includes the sponge region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.Ginsu-Union{Tuple{N}, Tuple{Tuple{Vararg{Real, N}}, Tuple{Vararg{Real, N}}, Tuple{Vararg{Int64, N}}, Tuple{Vararg{AbstractRange, N}}, Tuple{Vararg{Tuple{Int64, Int64}, N}}}} where N","page":"Reference","title":"JetPackWaveFD.Ginsu","text":"g = Ginsu(r0, dr, nr, aperturer, ndamp; T=Float32)\n\nCreate a Ginsu object from absolute aperture.\n\nrequired parameters[1,2]\n\naperturer::NTuple{Range} aperture in each dimension\n\n\n\n\n\n","category":"method"},{"location":"reference/#JetPackWaveFD.Ginsu-Union{Tuple{N}, Tuple{Tuple{Vararg{Real, N}}, Tuple{Vararg{Real, N}}, Tuple{Vararg{Int64, N}}, Tuple{Vararg{AbstractVector{Float64}, N}}, Tuple{Vararg{AbstractVector{Float64}, N}}, Tuple{Vararg{Tuple{Real, Real}, N}}, Tuple{Vararg{Tuple{Int64, Int64}, N}}}} where N","page":"Reference","title":"JetPackWaveFD.Ginsu","text":"g = Ginsu(r0, dr, nr, sour, recr, padr, ndamp; dims=(:z,:y,:x), stencilhalfwidth=2, vector_width=8)\n\nCreate a Ginsu object that defines the model aperture for a given shot.  g is used to subset earth  models using the sub and sub! methods, and provides the inverse operation using the super,  super! and super_accumulate! methods.  The padding for the earth model subset is determined  from the source and receiver positions, along with the padding padr and damping region ndamp  parameters.\n\nrequired parameters[1,2]\n\nr0::NTuple{N,Real} model origin in each model dimension\ndr::NTuple{N,Real} model cell widths in each model dimension\nnr::NTuple{N,Int} model cell counts in each model dimension\nsour::NTuple{N,Vector{Float}} source locations in each model dimension\nrecr::NTuple{N,Vector{Float}} receiver locations in each model dimension\npadr::NTuple{N,NTuple{Real,Real}} padding beyond the survey aperture in each model dimension[3,4]\nndamp::NTuple{N,NTuple{Int,Int}} damping region for absorbing boundaies in each model dimension[3,4]\n\nnamed optional parameters\n\ndim=(:z,:y,:x) axis ordering with the default being z fast, and x slow\nstencilhalfwidth=0 if there is a free-surface, set stencilhalfwidth, padr, and ndamp accordingly. This will add stencilhalfwidth cells above the free surface to allow copying the mirrored model to implement the free surface boundary condition.\nvector_width=8 sets the width required for vectorization of the code, and ensures that the size(ginsu) divided by vector_width has remainder zero for each dimension.\n\ntype specification\n\ng.lextrng is the logical (1-based) indices for the Ginsu model subset\ng.lintrng is the logical (1-based) indices for the Ginsu model subset interior\nrₒ is the physical origin of the Ginsu model subset\nδr is the grid cell sizes\n\nNotes\n\nN is the number of model dimensions\nrₒ[i] is the model origin along the ith model dimension\nthe model padding is the combination of padr and ndamp\npadr[i][1] is the padding for the dimension start, and padr[i][2] for the end.  The same is true for ndamp.\n\nExample (free-surface)\n\no---------------c---x--------------x---c-------o\n|               |   |              |   |       |\n|               |   |              |   |       |\n|               |   |              |   |       |\n|               |   |              |   |       |\n|               |   x--------------x   |       |\n|               |                      |       |\no---------------c----------------------c-------o\n\no denotes the original model\nc denotes the Ginsu module subset\nx denotes the Ginsu model subset interior\nthe region falling in-between the Ginsu model subset and the Ginsu model subset interior is the absorbing boundary region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"#JetPackWaveFD","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"","category":"section"},{"location":"#Space-and-time-discretization","page":"JetPackWaveFD","title":"Space and time discretization","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"These operators are implemented second order in time and 8th order in space.","category":"page"},{"location":"#Remarks-on-attentuation-and-propagator-evolution","page":"JetPackWaveFD","title":"Remarks on attentuation and propagator evolution","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"These propagators were originally used in monochromatic full waveform inversion. They incorporate a simple type of dissipation only Maxwell body attenuation, that when combined with a per-frequency wavelet estimation can provide a good approximation to visco-acoustic propagation for bandwidth within about an octave of dominant frequency. ","category":"page"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"For time domain full waveform inversion with bandwidth inside an octave of the center frequency of the attenuation model, the approximation used here performs well. To accurately model visco-acoustic attenuation with a larger bandwidth, a more sophisticated mechanism will be required: for example multiple filter banks implementing the widely used standard linear solid (SLS) model. ","category":"page"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"Note that we are in the process of open sourcing the description of our attenuation implementation. It derives from first principles of Maxwell Bodies, as shown in the Fung reference below. ","category":"page"},{"location":"#Self-adjoint-operators","page":"JetPackWaveFD","title":"Self-adjoint operators","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"These propagators are self-adjoint, meaning the same equations used for the nonlinear forward operations are also used for the linearized Jacobian forward and linearized Jacobian adjoint operations. ","category":"page"},{"location":"#Source-aperture-considerations","page":"JetPackWaveFD","title":"Source aperture considerations","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"This package includes a set of operations Ginsu that help in easily handling field seismic experiments. For typical narrow azimuth towed streamer marine field experiments the aperture required for a single source location may be much smaller than the entire model. ","category":"page"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"Ginsu provides methods to easily cut out part of the model that will be the correct size for the modeling aperture associated with individual source and receiver arrays. There are forward methods (sub and sub!) provided to extract a piece of a large model for use with individual shots. Similarly there are adjoint methods (super and super!) provided to add the contributions from individuals sources back to a larger model, for example when summing model perturbation contributions over sources for reverse time migration or full waveform inversion. ","category":"page"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"These Ginsu mechanisms are part of the operation of the JetPackWaveFD propagators. ","category":"page"},{"location":"#Support-for-simultaneous-sources","page":"JetPackWaveFD","title":"Support for simultaneous sources","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"The JetPackWaveFD propagators can take an array of source locations, and an array of per source delay times and wavelets, in order to ease the simulation of simultaneous (or blended) sources. See sz, sy, sx, and st in the help docs for the operators for more information.","category":"page"},{"location":"#Compression-and-serialization","page":"JetPackWaveFD","title":"Compression and serialization","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"In order to perform the linearized Jacobian operations, interactions with the nonlinear source wavefield are required. We compress and serialize the nonlinear source wavefield during computation, and then deserialize and decompress during the finite difference evolution for the Jacobian forward and adjoint operation. ","category":"page"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"We use the package CvxCompress.jl, which is built on the C++ library CvxCompress for wavelet compression.","category":"page"},{"location":"#Illumination-compensation","page":"JetPackWaveFD","title":"Illumination compensation","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"JetPackWaveFD operators provide the srcillum method to compute the source side illumination array, which is typically used as illumination compensation in full waveform inversion and reverse time migration. See help docs for srcillum for more information.","category":"page"},{"location":"#See-Also","page":"JetPackWaveFD","title":"See Also","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"WaveFD single time step modeling implementations wrapping high performance C++ kernels.\nSource Wavelets section in the WaveFD documentation, discussing a selection of wavelets commonly used in seismic modeling.\nJetPackWaveDevito package, implementing these same 6 operators using the Devito domain specific language https://www.devitoproject.org.","category":"page"},{"location":"#References","page":"JetPackWaveFD","title":"References","text":"","category":"section"},{"location":"","page":"JetPackWaveFD","title":"JetPackWaveFD","text":"Our implementation of self adjoint energy conserving propagators \nSelf-adjoint, energy-conserving second-order pseudoacoustic systems for VTI and TTI media for reverse migration and full-waveform inversion (2016). SEG Technical Program Expanded Abstracts. https://library.seg.org/doi/10.1190/segam2016-13878451.1\nPDF documents in the WaveFD package describing derivations for time update equations and linearization of constant density acoustics: https://github.com/ChevronETC/WaveFD.jl/blob/master/docs/latex_notes.\nMaxwell body reference   Fung, Y.C., A First Course in Continuum Mechanics, Prentice-Hall, 1977.\nInterpolation in JetPackWaveFD for off-grid physical locations \nBilinear: https://en.wikipedia.org/wiki/Bilinear_interpolation\nTrilinear: https://en.wikipedia.org/wiki/Trilinear_interpolation\nSinc: Arbitrary source and receiver positioning in finite‐difference schemes using Kaiser windowed sinc functions (2002). Graham Hicks, Geophysics, Vol. 67. https://library.seg.org/doi/10.1190/1.1451454\nStability condition for temporal discretization in finite difference solution of PDEs\nhttps://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition\nWeak elastic anisotropy\nWeak elastic anisotropy (1986). Leon Thomsen, Geophysics, Vol. 51. https://library.seg.org/doi/abs/10.1190/1.1442051\nAcoustic approximations for processing in transversely isotropic media (1998). Tariq Alkhalifah, Geophysics, Vol. 63. https://library.seg.org/doi/pdf/10.1190/1.1444361","category":"page"}]
}
